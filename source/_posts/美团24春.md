## 考情分析

## 知识点补充

### 1. 强缓存和弱缓存

在Web开发中，**强缓存(Strong Cache)**和**弱缓存/协商缓存**是浏览器缓存机制的两种形式。他们的目标都是**减少了不必要的网络请求，提高页面加载速度和性能**.

|          | 强缓存                                                       | 弱缓存                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义     | **浏览器直接使用缓存内容，不与服务器进行任何通信**，及时刷新页面，也不会向服务器发送请求。 | **浏览器在使用缓存前会先向服务器发送请求询问资源是否更新**，服务器决定是否返回新的资源。 |
| 生效标志 | 通过**响应头**中的以下字段设置：<br />- `Expires`：一个绝对的时间点(HTTP/1.0)<br />- `Cache-Control: max-age=秒数`: 一个相对的时间(HTTP/1.1, 优先级更高) | 通过响应头的以下字段设置：<br />- `Last-Modified` + 请求头`If-Modified-Since`<br />- `ETag`+请求头`If-None-Match` |
| 工作流程 | 1. 浏览器加载资源时，服务器返回资源内容+设置了强缓存的相关头。<br />2. 在规定的时间内再次访问资源，浏览器直接使用缓存，不发送请求。 | 1. 浏览器首次请求资源，服务器返回内容+`ETag`或`Last-Modified`。<br />2. 下次请求时，浏览器携带`If-None-Match`或`If-Modified-Since`向服务器验证。<br />3.服务器判断资源是否改变：<br />- 若没有改变，返回`304 Not Modified`,浏览器使用缓存。<br />- 若改变，返回`200OK`和最新资源内容 |
| 特点     | - 不与服务器通信<br />- 性能最好<br />- 适合静态资源         | - 有请求发送<br />-节省了传输内容，但仍消耗了服务器计算与网络开销<br /><br />相比强缓存性能略差 |
| 示例     | `Cache-Control: max-age=3600`                                | 第一次响应<br />```http<br />ETag: "abc123"<br/>Last-Modified: Wed, 22 Jul 2025 07:28:00 GMT<br />```<br />第二次请求：<br />```http<br />If-None-Match: "abc123"<br/>If-Modified-Since: Wed, 22 Jul 2025 07:28:00 GMT<br />``` |

### 2. CPU调度

一、调度基础概念与分类

1. 调度目标

- CPU利用率：最大化CPU忙碌时间
- 吞吐量：单位时间内完成的作业数（短作业优先可以提升吞吐量）
- 响应时间：用户请求到首次响应的延迟（关键于交互式系统）
- 公平性：防止进程饥饿（长、短作业均需合理调度）

2. 调度方式

- 非抢占式调度：进程主动释放CPU后才切换（如FCFS），实现简单但响应慢。
- 抢占式调度：强制中断当前进程（如时间片用完，高优先级进程先到达），响应快但切换开销大。

二、经典调度算法详解

1. 先来先服务（FCFS）

- 原理：按作业、进程到达顺序调度，非抢占式
- 示例：进程P1（10ms），P2（5ms），P3（3ms）依次到达，则顺序执行，平均等待时间为$(0 + 10 + 15)/3 \approx 8.33ms $
- 优点：简单公平，利于长作业和CPU密集型任务
- 缺点：护航效应（短作业被长作业阻塞），I/O密集型任务效率低。

2. 短作业优先（SJF）

- 原理：优先调度**预估执行时间最短**的进程，分非抢占与抢占式（**最短剩余时间优先，SRTF**）
- 优点：理论最小平均等待时间（短作业快速完成）
- 缺点：长作业饥饿；依赖用户预估时间（不准确则失效）

3. 优先级调度（PSA）

- 原理：按静态/动态优先级分配CPU，高优先级优先执行
  - 静态优先级：创建时确定（如系统进程>用户进程）
  - 动态优先级：随等待时间增长提升优先级（避免饥饿）
- 缺点：低优先级任务可能长期阻塞（需结合”老化“机制）

4. 时间片轮转（RR）

- 原理：为每个进程分配固定的时间片，超时后剥夺并放入队尾，抢占式
- 时间片影响：
  - 过小->切换频繁，CPU开销大
  - 过大->退化为FCFS
- 适用场景：分时系统（如Linux终端交互）

5. 多级反馈队列（MLFQ）

- 原理：
  - 多队列（优先级高->低），时间片逐级加倍
  - 新进程入最高优先级队列，未完成则降级；仅高优先级队列空时才调度低优先级队列
- 优点：
  - 短作业& I/O密集型->快速响应（高优先级队列处理）
  - 长作业->低优先级队列按FCFS/RR执行（避免饥饿）
- 缺点：实现复杂，需动态管理队列

6. 高响应比优先（HRRN）

- 原理：响应比 = （等待时间 + 预估运行时间）/预估运行时间，优先调度响应比高者。
- 优点：平衡长短作业（短作业响应比高，长作业随着等待时间增长而提升）
- 缺点：计算开销大，不适用实时系统。

| 指标     | 定义                           | 优化目标               |
| -------- | ------------------------------ | ---------------------- |
| 周转时间 | 作业提交到完成的总时间         | 最小化（SJF最优）      |
| 等待时间 | 进程在就绪队列中的累计等待时间 | 最小化（SJF最优）      |
| 响应时间 | 请求到首次响应的时间           | 最小化（RR、MLFQ最优） |
| 吞吐量   | 单位时间内完成的作业数         | 最大化（短作业优先）   |
| 公平性   | 各进程/用户获得合理的CPU份额   | 避免饥饿（MLFQ最优）   |



### 3. SCAN调度

SCAN调度算法（又称电梯调度算法）是磁盘I/O调度中的核心策略，通过模拟电梯运行模式优化磁头移动路径，以最小化寻到时间并平衡公平性。

一、核心原理与工作流程

1. 基本思想

- 磁头沿固定方向（如从低磁道向高磁道）移动，依次处理该方向上所有未完成的请求，直至到达磁盘边界（如磁道0或最大磁道）
- 到达边界后立即反转方向，沿相反路径处理请求，形成往复扫描模式

2. 关键步骤（以磁头起始位置50、请求队列`[98, 183, 37, 122, 14, 124, 65, 67]`、磁盘范围0-199为例

- 初始化：设定磁头初始方向（如向右/磁道号增大）
- 同向扫描：处理当前方向所有请求（向右访问：65→67→98→122→124→183）
- 反向扫描：到达磁盘尽头（183->199）后掉头，处理反方向请求（向左访问: 14->37)

二、 优势与缺陷分析

1. 核心优势

- 高效性：减少磁头来回摆动，显著降低平均寻道时间（比FCFS算法提升30%以上）
- 公平性：避免“饥饿现象”，所有请求最终都会被处理（与SSTF算法相比）
- 顺序优化：适合连续磁道请求（如大文件读写），利用局部性原理提升吞吐量

2. 主要缺陷

- 边界延迟：位于磁盘另一端的请求需要等待磁头往返（例如：磁头在0时，199号磁道请求需等待全程扫描
- 实时性不足：新到达远端的请求可能被延迟处理。



### 4. 常用SQL

一、 四种连接方式

1. 内连接：只返回两个表中**都**存在匹配的行
2. 左外连接： 返回左表的所有行，即使在右表中没有匹配的行。对于右表没有匹配的行，结果集中右表的部分显示为 NULL
3. 右外连接：返回右表的所有行，即使在左表中没有匹配的行。对于左表没有匹配的行，结果集中左表的部分显示为 NULL。
4. 全连接：返回左表和右表中的所有行。当某一行在另一个表中没有匹配时，另一个表的部分显示为 NULL。

---

二、索引的建立

索引在数据库中的作用就像一个书的目录，它能极大地加速基于特定列的查询速度（尤其是WHERE，JOIN，ORDER BY等子句）。但建立和和维护索引是有代价的（占用存储空间，降低写入速度），因此必须明智地选择那些最能提升查询性能的列。

**索引选择黄金法则**

1. 高选择性/区分度

- 索引最有效的情形是：当通过索引值查询时，能迅速定位到表中极少数或唯一的行。
- 理想状态：列的值几乎是唯一的，或每个值对应的行数非常少
- 效果差：如果列的值种类很少（计数低）或某个值对一个大量的行，使用索引查到的记录太多，数据库反而可能放弃索引进行全表扫描

2. 查询频率和使用场景

- 最常出现在WHERE条件中的列是索引的首要候选者
- 常用于连接（JOIN）条件的列（外键列）也非常适合索引。
- 用于排序（ORDER BY）或分组（GROUP BY）的列，索引也能提升速度

3. 数据长度

- 索引列值越大（如长文本），索引本身占用的空间就越大，维护成本（插入、更新，删除时的索引调整）也越高，效率相对更低。

---

三、聚合函数

以下详细说明 SQL 中 `GROUP BY`、`ORDER BY`、聚合函数（`SUM`, `COUNT`, `AVG`, `MAX`, `MIN`）及 `BETWEEN` 的使用方法，结合语法说明和实例演示。

------

### **一、聚合函数：汇总数据**

聚合函数对一组值计算并返回单一结果，常与 `GROUP BY` 结合使用。

#### **常用函数及示例**

| **函数**  | **作用**            | **示例**                              | **结果说明**             |
| --------- | ------------------- | ------------------------------------- | ------------------------ |
| `SUM()`   | 求和                | `SELECT SUM(sales) FROM orders;`      | 计算 `sales` 列总和      |
| `COUNT()` | 计数（忽略 `NULL`） | `SELECT COUNT(order_id) FROM orders;` | 统计非空 `order_id` 数量 |
| `AVG()`   | 平均值              | `SELECT AVG(price) FROM products;`    | 计算 `price` 的平均值    |
| `MAX()`   | 最大值              | `SELECT MAX(salary) FROM employees;`  | 返回 `salary` 的最大值   |
| `MIN()`   | 最小值              | `SELECT MIN(age) FROM users;`         | 返回 `age` 的最小值      |

**注意事项**

- `COUNT(*)` 统计所有行（包括 `NULL`），`COUNT(column)` 忽略 `NULL` [9,10](https://tencent.yuanbao/@ref)。
- 非数值类型（如文本）也可用 `MAX/MIN`（按字典序排序）[10](https://tencent.yuanbao/@ref)。

------

### **二、GROUP BY：分组统计**

`GROUP BY` 将数据按指定列分组，再对每组应用聚合函数。

#### **1. 基本语法**

```
SELECT column1, SUM(column2) 
FROM table 
GROUP BY column1;
```

#### **2. 示例**

- 

  统计每个部门的工资总和

  

  ```
  SELECT department, SUM(salary) AS total_salary
  FROM employees
  GROUP BY department;
  ```

- 

  多列分组（如部门+职位）

  

  ```
  SELECT department, job_title, AVG(salary) 
  FROM employees 
  GROUP BY department, job_title;
  ```

  

  输出示例

  ：

  | `department` | `job_title` | `AVG(salary)` |
  | ------------ | ----------- | ------------- |
  | HR           | Manager     | 8000          |
  | HR           | Assistant   | 4500          |

#### **3. 结合 `HAVING` 过滤分组**

```
SELECT department, AVG(salary) 
FROM employees 
GROUP BY department 
HAVING AVG(salary) > 5000;  -- 过滤平均工资＞5000的部门
```

**⚠️ 注意**

- `SELECT` 中的非聚合列必须出现在 `GROUP BY` 中，否则报错[2,4](https://tencent.yuanbao/@ref)。
- `HAVING` 过滤分组后的结果，`WHERE` 过滤原始数据（执行顺序：`WHERE` → `GROUP BY` → `HAVING`）[4,5](https://tencent.yuanbao/@ref)。

------

### **三、ORDER BY：结果排序**

对查询结果按指定列排序，默认升序（`ASC`），降序用 `DESC`。

#### **1. 基本语法**

```
SELECT column1, column2 
FROM table 
ORDER BY column1 [ASC|DESC], column2 [ASC|DESC];
```

#### **2. 示例**

- 

  单列降序（工资从高到低）

  

  ```
  SELECT name, salary FROM employees ORDER BY salary DESC;
  ```

- 

  多列排序（先部门升序，同部门按工资降序）

  

  ```
  SELECT department, name, salary 
  FROM employees 
  ORDER BY department ASC, salary DESC;
  ```

  

  输出示例

  ：

  | `department` | `name` | `salary` |
  | ------------ | ------ | -------- |
  | HR           | Alice  | 9000     |
  | HR           | Bob    | 7000     |
  | IT           | Carol  | 8500     |

**⚠️ 注意**

- 可对聚合结果排序（如分组后的总工资）

  7,8

  ：

  ```
  SELECT department, SUM(salary) AS total 
  FROM employees 
  GROUP BY department 
  ORDER BY total DESC;  -- 按总工资降序
  ```

------

### **四、BETWEEN：范围查询**

筛选指定范围内的数据（**包含边界值**），适用于数字、文本、日期。

#### **1. 基本语法**

```
SELECT column1 
FROM table 
WHERE column2 BETWEEN value1 AND value2;  -- 等效于 column2 ≥ value1 AND column2 ≤ value2
```

#### **2. 示例**

- 

  数字范围（工资在 5000~10000）

  

  ```
  SELECT name, salary 
  FROM employees 
  WHERE salary BETWEEN 5000 AND 10000;
  ```

- 

  日期范围（1996年7月4日~9日的订单）

  

  ```
  SELECT * FROM orders 
  WHERE OrderDate BETWEEN '1996-07-04' AND '1996-07-09';
  ```

- 

  文本范围（名字在 'Adams'~'Carter'）

  

  ```
  SELECT * FROM persons 
  WHERE LastName BETWEEN 'Adams' AND 'Carter';
  ```

#### **3. 结合 `NOT` 排除范围**

```
SELECT * FROM products 
WHERE price NOT BETWEEN 10 AND 20;  -- 价格＜10 或 ＞20
```

**⚠️ 重要注意事项**

- **边界值处理**：多数数据库（如 MySQL、SQL Server）包含边界值，但部分数据库可能行为不同，需验证[13,14](https://tencent.yuanbao/@ref)。
- **日期格式**：不同数据库日期写法不同（如 MySQL 用 `'YYYY-MM-DD'`，Access 用 `#MM/DD/YYYY#`）[13](https://tencent.yuanbao/@ref)。

------

### **五、完整综合示例**

**需求**：统计 2023 年每个部门的订单总金额，仅显示总金额 > 1 万元的部门，并按金额降序排序。

```
SELECT department, SUM(amount) AS total_amount
FROM orders
WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'  -- 过滤2023年订单
GROUP BY department
HAVING SUM(amount) > 10000  -- 过滤总金额＞1万的部门
ORDER BY total_amount DESC; 
```

**执行顺序解析**：

1. `WHERE` 筛选 2023 年订单 → 2. `GROUP BY` 按部门分组 → 3. `SUM(amount)` 计算每组总金额 → 4. `HAVING` 过滤金额＞1万的组 → 5. `ORDER BY` 按总金额降序输出。



