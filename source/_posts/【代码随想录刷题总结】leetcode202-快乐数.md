---
title: 【代码随想录刷题总结】leetcode202-快乐数
date: 2025-07-04 09:25:12
tags: 代码随想录 leetcode 链表
categories: leetcode
top_img: /img/leetcode.png
cover: /img/leetcode.png
---

## 引言

大家好啊，我是前端拿破轮😁。

跟着卡哥学算法有一段时间了，通过[代码随想录](https://programmercarl.com/)的学习，受益匪浅，首先向卡哥致敬🫡。

但是在学习过程中我也发现了一些问题，很多当时理解了并且AC的题目过一段时间就又忘记了，或者不能完美的写出来。根据**费曼学习法**，光有输入的知识掌握的是不够牢靠的，所以我决定**按照代码随想录的顺序，输出自己的刷题总结和思考**。同时，由于以前学习过程使用的是`JavaScript`,而在2025年的今天，`TypeScript`几乎成了必备项，所以本专题内容也将使用`TypeScript`，来巩固自己的`TypeScript`语言能力。

## 题目信息

快乐数

[leetcode题目链接](https://leetcode.cn/problems/happy-number/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

## 题目分析

这个题目乍一看像一个数学问题，实际上并不是。关键在于题目中提到的要么在这个过程中成为1，要么**无限循环**但始终变不到一。

所谓的**无限循环**不就是**之前出现过的数还会再次出现**的意思吗？显然判断这种**某个数是否在集合中出现过或出现多少次**，最常用的就是**哈希表**了。

在本题目中，我们只需要使用一个Set。将每一次的每个位置上的平方和sum添加到Set中。一旦sum等于1，就返回true。如果sum没有出现过1，并且出现了循环，那么就意味着**它永远不会再出现1了！！！**。直接返回false。

上述便是此题的核心思想，至于说怎么求每一位的平方和，就很多方法了，可以把数字转成字符串再分割为数组然后求平方和，也可以直接使用求余数的方式把各个位置的数字求出来，再求平方和。

此外，本题还有另一种思路，就是**双指针**。因为如果sum变为1之后，就一定永远是1，$1^2 = 1$,所以就相当于是一个只有一个元素的环。而其他无限循环的情况就类比为不止一个元素的环。整个题目可以类比[🤯🤯🤯我人麻了！！！面试官：怎么判断链表是否有环？用两种不同的方法😏😏😏](https://juejin.cn/post/7522367598814773257)这篇文章的解法了。

把快乐数的循环当作链表的环，就成了判断链表环的问题，和之前的两种思路**哈希表和双指针**是一致的。

在这个情境中，慢指针每轮进行一次求和操作，而快指针每轮进行两次求和操作。当快满指针的求和相等时进行判断，如果相等的和为1，那么就是快乐数，否则不是。

## 题解

### 哈希表法

```ts
function isHappy(n: number): boolean {
    // set集合存放sum
    const set: Set<number> = new Set();

    // 开始循环
    while (true) {
        // 计算每一位的平方和
        const sum = [...String(n)].reduce((acc, cur) => acc + Number(cur) ** 2, 0);
        if (sum === 1) return true;
        if (set.has(sum)) return false;

        // 加入set
        set.add(sum);
        // 更新n
        n = sum;
    }
};
```
时间复杂度：O(logn)
空间复杂度：O(logn)

### 双指针法

```ts
function isHappy(n: number): boolean {
    // set集合存放sum
    const set: Set<number> = new Set();

    // 开始循环
    while (true) {
        // 计算每一位的平方和
        const sum = [...String(n)].reduce((acc, cur) => acc + Number(cur) ** 2, 0);
        if (sum === 1) return true;
        if (set.has(sum)) return false;

        // 加入set
        set.add(sum);
        // 更新n
        n = sum;
    }
};
```
时间复杂度：O(logn)
空间复杂度：O(1)

## 总结

本题考查的快乐数可以转换为链表环的判断，同样是哈希表和双指针两种思路。前者更容易理解，后者空间复杂度更优。

好了，这篇文章就到这里啦，如果对您有所帮助，欢迎点赞,收藏,分享👍👍👍。您的认可是我更新的最大动力。由于笔者水平有限，难免有疏漏不足之处，欢迎各位大佬评论区指正。

> 往期推荐✨✨✨
> - [🤯🤯🤯我人麻了！！！面试官：怎么判断链表是否有环？用两种不同的方法😏😏😏](https://juejin.cn/post/7522367598814773257)
> - [🤡🤡🤡字母异位词是个啥？用哈希还是排序？](https://juejin.cn/post/7522388188947398696)
> - [CJS和ESM两种模块化标准的异同分析](https://juejin.cn/post/7473814041867780130)
> - [🤔5202年了，你不会还不知道WebAssembly吧？](https://juejin.cn/post/7498988293209784374)
> - [🚀🚀🚀实在受不了混乱的提交——我使用了commitlint和commitizen](https://juejin.cn/post/7508919522905522226)
> - [当我用deepwiki来学习React源码](https://juejin.cn/post/7514876424806334504)
> - [【🚀🚀🚀代码随想录刷题总结】leetcode707-设计链表](https://juejin.cn/post/7519769941501165631)
> 

我是前端拿破轮，关注我，和您分享前端知识，我们下期见！