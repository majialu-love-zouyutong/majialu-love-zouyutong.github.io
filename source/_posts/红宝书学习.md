---
title: 红宝书学习
date: 2025-06-16 21:11:11
tags: 红宝书 js
---

# 概述

1. 介绍JavaScript的起源：从哪里来，如何发展，以及现今的状况。这一章会谈到JavaScript与ECMAScript的关系，DOM，BOM，以及ECMA和W3C相关的标准。
2. 介绍JavaScript如何与HTML结合起来创建动态网页，主要介绍在网页中嵌入JavaScript的不同方式，还有JavaScript的内容类型及其与`<script>`元素的关系。
3. 介绍语言的基本概念，包括语法和流控制语句；解释JavaScript与其他类C语言在语法上的异同点。在讨论内置操作符时也会谈到强制类型转换。此外还将介绍所有的原始类型，包括Symbol。
4. 探索JavaScript松散类型下的变量处理。这一章将涉及原始类型和引用类型的不同，以及与变量有关的执行上下文。此外，这一章也会讨论JavaScript中的垃圾回收，涉及在变量超出作用域时如何回收内存。
5. 讨论JavaScript所有内置的引用类型。如Date， Regexp，原始类型及其包装类型。每种引用类型既有理论上的讲解，也有相关浏览器实现的剖析。
6. 继续讨论内置引用类型，包括Object，Array，Map，WeakMap，Set和WeakSet等。
7. 介绍ECMAScript新版中引入的两个基本概念：迭代器和生成器，并分别讨论他们最基本的行为和在当前语言环境下的应用。
8. 解释如何在JavaScript中使用类和面向对象编程。首先会深入讨论JavaScript的Object类型，进而探讨原型式继承，接下来全面介绍ES6类及其与原型式继承的紧密关系。
9. 介绍两个紧密相关的概念：Proxy(代理)和反射(Reflect)API。代理和反射用于拦截和修改这门语言的基本操作。
10. 探索JavaScript最强大的一个特性：函数表达式，主要涉及闭包，this对象，模块模式，创建私有对象成员，箭头函数，默认参数和扩展操作符。
11. 介绍两个紧密相关的异步编程构造：Promise类型和async/await。这一章讨论JavaScript的异步编程范式，进而介绍promise与异步函数的关系。
12. 介绍BOM，即浏览器对象模型，跟与浏览器本身交互的API相关。所有BOM对象都会涉及，包括window,document,location,navigator和screen等。
13. 解释检测客户端机器及其能力的不同手段，包括能力检测和用户代理字符串检测。这一章讨论每种手段的优缺点，以及适用场景。
14. 介绍DOM，即文档对象模型，主要是DOM Level 1定义的API。这一章将简单讨论XML及其与DOM的关系，进而全面探索DOM以及如何利用它操作网页。
15. 解释其他DOM API，包括浏览器本身对DOM的扩展，主要涉及Selectors API和Element Traversal API 和HTML5扩展。
16. 在之前两章的基础上，解释DOM Level 2和Level 3对DOM的扩展，包括新增的属性，方法和对象。这一章还会介绍DOM4的相关内容，比如Mutaion Observer。
17. 解释事件在JavaScript中的本质，以及事件的起源及其在DOM中的运行方式。
18. 围绕`<canvas>`标签讨论如何创建动态图形，包括2D和3D上下文(WebGL)等动画和游戏开发所需的基础。这一章还会讨论WebGL1和WebGL2.
19. 探索使用JavaScript增强表单交互及突破浏览器限制，主要讨论文本框，选择框等表单元素及数据验证和操作。
20. 介绍各种JavaScript API，包括Atomics，Encoding，File，Blob，Notifications，Streams，Timing，Web Components和Web Cryptography。
21. 讨论浏览器如何处理JavaScript代码中的错误及集中错误处理方式。这一章同时介绍了每种浏览器的调试工具和技术，包括简化调试过程的建议。
22. 介绍通过JavaScript读取和操作XML数据的特性，解释了不同浏览器支持特性和对象的差异，提供了简化跨浏览器编码的建议。这一章也讨论了使用XSLT在客户端转换XML数据。
23. 介绍作为XML替代的JSON数据格式，还讨论了浏览器原生解析和序列化JSON，以及适用JSON时要注意的安全问题。
24. 讨论浏览器请求数据和资源的常用方式，包括早期的XMLHttpRequest对象，以及现代的Fetch API。
25. 讨论应用程序离线时在客户端机器上存储数据的各种技术。先从cookie谈起，然后讨论Web Storage 和 IndexedDB。
26. 介绍模块模式在编码中的应用，进而讨论ES6模块之前的模块加载方式，包括CommonJS，AMD和UMD。最后介绍新的ES6模块及其正确用法。
27. 深入介绍专用工作者线程，共享工作者线程和服务工作者线程。其中包括工作者线程在操作系统和浏览器层面的实现，以及使用各种工作者线程的最佳策略。
28. 讨论在企业级开发中进行JavaScript编码的最佳实践。其中提到了提升代码可维护性的编码惯例，包括编码技巧，格式化及通用编码建议。深入讨论应用性能和提升速度的技术。最后介绍上线与部署相关的话题，包括项目构建流程。

# 第1章 什么是JavaScript

> 本章内容
> - JavaScript历史回顾
> - JavaScript是什么
> - JavaScript与ECMAScript的关系
> - JavaScript的不同版本

![20250616215345](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616215345.png)

> 这里这张图个人认为有点问题，DOM应该属于BOM，DOM是BOM的一部分，不应该和BOM并列。

ECMA-262到底定义了什么？
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 全局对象

## DOM

![20250616220143](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616220143.png)

![20250616220153](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616220153.png)

### DOM级别

1998年10月，**DOM Level 1**成为W3C的推荐标准。该规范由两个模块组成：DOM Core和DOM HTML。前者提供了一种映射XML文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者，并增加了特定于HTML的对象和方法。

> 注意DOM并非只能通过JavaScript操作，也可以通过其他语言操作。不过对于浏览器来说，DOM就是使用ECMAScript实现的，如今已经成为JavaScript语言的一大组成部分。

DOM Level 1的目标是映射文档结构，而DOM Level2的目标则宽泛的多。增加了对鼠标和用户界面事件，范围，遍历（迭代DOM节点的方法）的支持，而且通过对戏那个接口支持了CSS。另外，DOM Level1 中的DOM Core也被扩展以包含对XML命名空间的支持。

**DOM Level 2**新增了以下模块：

- DOM视图：描述追踪文档不同视图（如应用CSS样式前后的文档）
- DOM事件：描述事件及事件处理的接口
- DOM样式：描述处理元素CSS样式的接口
- DOM遍历和范围：描述遍历和操作DOM树的接口

**DOM Level 3**增加了以统一方式加载和保存文档的方法(包含在DOM Load and Save新模块中)，还有验证文档的方法(DOM Validation)。在Level 3中，DOM Core模块被扩展，支持了所有XML1.0的特性，包括XML Infoset，XPath 和XML Base。

目前，W3C不再按照Level来维护DOM了，而是作为DOM Living Standard来维护，其快照成为DOM4. DOM4新增的内容包括替代Mutaion Events的Mutation Observers。

### 其他DOM

除了DOM Core和DOM HTML接口，其他语言也发布了自己的DOM标准，下面列出的语言是基于XML的，每一种都增加了该语言独有的DOM方法和接口。

- 可伸缩矢量图(SVG, Scalable Vector Graphics)
- 数学标记语言(MathML, Mathematical Markup Language)
- 同步多媒体集成语言(SMIL, Synchronized Multimedia Integration Language)

此外还有一些语言也开发了自己的DOM实现，比如Mozilla的XML用户界面语言(XUL, XML User Interface Language)，不过，只有前面列表中的语言是W3C推荐的标准。

## BOM

HTML5涵盖了尽可能多的BOM特性。

总体来说，BOM主要针对浏览器窗口和子窗口(frame)，不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如，下面就是这样一些扩展：

- 弹出新浏览器窗口的能力
- 移动，缩放和关闭浏览器窗口的能力
- navigator对象，提供关于浏览器的详尽信息
- location对象，提供浏览器加载页面的详尽信息
- screen对象，提供关于用户屏幕分辨率的详尽信息
- performance对象，提供浏览器内存占用，导航行为和事时间统计的详尽信息
- 对cookie的支持
- 其他自定义对象，如XMLHttpRequest

## 小结

JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。
- ECMAScript：由ECMA-262定义并提供的核心功能
- DOM：提供与网页内容交互的方法和接口
- BOM：提供与浏览器交互的方法和接口

# 第2章 HTML中的JavaScript

> 本章内容
> - 使用`<script>`元素
> - 行内脚本与外部脚本比较
> - 文档模式对JavaScript有什么影响
> - 确保JavaScript不可用时的用户体验

将JavaScript插入HTML的主要方法是使用`<script>`元素，这个元素已经被正式加入HTML规范。

`<script>`元素有下列8个属性：

- **src**：可选。表示包含要执行的代码的外部文件。
- **async**：可选。表示应该**立即开始下载脚本**，但是**不能阻止页面其他动作**，比如下载资源或等待其他脚本加载。只对外部脚本有效。
- charset：可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
- crossorigin：可选。配置相关请求的CORS(跨域资源共享)设置。默认不使用CORS。`crossorigin="anonymous"`配置文件请求不必设置凭据标志。`crossorigin="use-credentials"`设置凭据标志，意味着出站请求会包含凭据。
- **defer**：可选。表示**脚本可以延迟到文档完全被解析和显示之后再执行**。只对外部脚本有效。
- integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性(SRI, Subresource Integrity)。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可用于**确保CDN不会提供恶意内容**。
- language: 废弃。最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript 1.2"
或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。
- **type**：可选。代替language，表示代码块中脚本语言的类型(也称为MIME类型)。按照惯例，这个值始终都是"text/javascript".尽管"text/javascript"和"text/ecmascript"都已经废弃了。JavaScript的MIME类型是"application/x-javascript"，不过给type属性这个值可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。**如果这个值是module，则代码会被当做ES6模块，而且只有这时候，代码中才能出现import和export**。

使用`<script>`的方式有两种：
- 行内脚本：将脚本放在`<script>`元素的内容中。
- 外部脚本：将脚本放在外部文件中，并使用src属性将外部脚本引入HTML文档中。

浏览器解析行内脚本的方式决定了它在看到字符串`</script>`时，会将其当成结束的`</script>`标签。想避免这个问题，只需要传递转义字符`\`即可：

```html
  <script>
    console.log("<\/script>")
  </script>
```

> 注意：使用了src属性的`<script>`元素不应该在`<script>`和`</script>`之间包含其他JavaScript代码。如果两者都提供的话，浏览器只会下载并执行脚本文件，从而**忽略行内代码**。

> `<script>`标签的src属性可以引入外部域的脚本文件，不受浏览器同源策略的限制。
> 但是这个可能会导致安全问题，使用`<script>`标签的integrity属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持。

在没有使用`async`和`defer`的情况下，浏览器会按照`<script>`标签在页面中出现的顺序依次解释他们。

使用了`defer`的脚本会在浏览器解析到结束的`</html>`标签后才会执行。HTML5规范要求脚本应该按照他们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，**而且两者都在`DOMContentLoaded`事件之前执行。**

使用了`async`的脚本会在**页面的load事件之前执行，但可能会在DOMContentLoaded事件之前或之后执行**，而且**无法保证脚本的顺序**。所以，在async脚本中，不要对DOM进行操作。

## 动态加载脚本

除了`<script>`标签，还有其他方式可以加载脚本。因为JavaScript可以使用DOM API，所以通过DOM中动态添加script元素同样可以加载指定的脚本。只要创建一个script元素并将其添加到DOM即可。

```js
let script = document.createElement('script');
script.src = 'gibberish.js';
document.body.appendChild(script);
```
默认情况下，以这种方式创建的`<script>`元素是**异步加载**的，相当于添加了`async`属性。

以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响他们在资源获取队列中的优先级。这种方式可能会严重影响性能。要想让浏览器**预加载器**直到这些动态请求文件的存在，可以在文档头部显式声明他们：

```html
<link rel="preload" href="gibberish.js">
```

## 文档模式

IE5.5发明了文档模式的概念，即可以使用DOCTYPE来切换文档模式。最初的文档模式有两种：
- 怪异模式/混杂模式(quirks mode)
- 标准模式(standards mode)

在HTML文件中第一行的代码，目的就是告诉浏览器使用标准模式解析文档，不要使用怪异模式。

```html
<!DOCTYPE html>
```

## `<noscript>`元素

针对早期浏览器不支持 `JavaScript` 的问题，需要一个页面优雅降级的处理方案。最终，`<noscript>`
元素出现，被用于给不支持 `JavaScript` 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持
JavaScript，但对于禁用 `JavaScript` 的浏览器来说，这个元素仍然有它的用处。
`<noscript>`元素可以包含任何可以出现在`<body>`中的 HTML 元素，`<script>`除外。在下列两种
情况下，浏览器将显示包含在`<noscript>`中的内容：

- 浏览器不支持脚本
- 浏览器对脚本的支持被关闭

任何一个条件被满足，包含在`<noscript>`中的内容就会被渲染。否则，浏览器不会渲染`<noscript>`中的内容。

```html
<!DOCTYPE html>
<html>
 <head>
 <title>Example HTML Page</title>
 <script defer="defer" src="example1.js"></script>
 <script defer="defer" src="example2.js"></script>
 </head>
 <body>
 <noscript>
 <p>This page requires a JavaScript-enabled browser.</p>
 </noscript>
 </body>
</html> 
```

# 第3章 语言基础

## 3.1 语法

1. 变量名区分大小写
2. 标识符：变量，函数，属性或函数参数的名称：
  - 第一个字符必须是字母，下划线，或美元符
  - 后续字符可以是字母，数字，下划线，或美元符
标识符中的字母可以是扩展ASCII(Extended ASCII)中的字母，也可以是Unicode的字母字符。

## 3.2 严格模式

ECMAScript 5 引入了严格模式(strict mode)。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

可以在整个文件或某个函数中开启严格模式，只需要加上`"use strict";`

```js
"use strict"
```

```js
function doSomething() {
  "use strict"
  // 函数体
}
```

## 3.3 分号插入

在JavaScript中，分号`;`是可选的，但是为了避免错误，还是建议加上分号。

## 3.4 关键字与保留字

![20250625182346](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250625182346.png)

![20250625182415](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250625182415.png)

这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字
和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。

## 3.5 变量

ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6 及更晚的版本中使用。

| 关键字   | `var`                       | `let`                       | `const`                                            |
| -------- | --------------------------- | --------------------------- | -------------------------------------------------- |
| 作用域   | 函数作用域                  | 块级作用域                  | 块级作用域                                         |
| 初始化   | 可以不初始化，值为undefined | 可以不初始化，值为undefined | 必须初始化                                         |
| 提升     | 提升到函数作用域顶部        | TDZ暂时性死区               | TDZ暂时性死区                                      |
| 重复声明 | 后者覆盖前者                | ReferenceError              | ReferenceError                                     |
| 重复赋值 | 更新为新值                  | 更新为新值                  | 重新赋值会导致运行时错误，但是可以改变对象的属性值 |
| 全局声明 | 称为window对象的属性        | 不会挂载到全局对象          | 不会挂载到全局对象                                 |

## for循环中的let声明

在let出现之前，**for循环定义的迭代变量会渗透到循环体外部**：

```js
for (var i = 0; i < 5; i++) {
  // 循环逻辑
}
console.log(i); // 5
```

改用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块的内部：

```js
for (let i = 0; i < 5; i++) {
  // 循环逻辑
}
console.log(i);	// ReferenceError：i is not defined
```

在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改：

```js
for (var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

你可能以为会输出0,1,2,3,4

实际上会输出5,5,5,5,5

之所以会这样，是因为在退出循环时，迭代变量保存的是**导致循环退出的值**：5.在之后执行超时逻辑时，所有的i使用的都是同一个变量，因为输出的都是同一个最终值。

而在使用let声明迭代变量时，JavaScript在后台会**为每个迭代循环声明一个新的迭代变量**。每个`setTimeout`引用的都是不同的变量实例，所以`console.log`输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。

```js
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0);
}
// 输出 0,1,2,3,4
```

这种每次迭代声明一个独立变量实例的行为适用于**所有风格的for循环**。包括`for-in`和`for-of`循环。

JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，虽然const变量跟let变量很相似，但是不能用const来声明迭代变量（因为迭代变量会自增）

```js
for (const i = 0; i < 10; i++)	// TypeError: Assignment to constant variable
```

不过，可以用const声明一个不会被修改的for循环变量。也就是说，每次迭代只是创建一个新变量。这对`for-of`和`for-in`循环特别有意义。

```js
let i = 0;
for (const j = 7; i < 5; i++) {
  console.log(j);
}
// 7,7,7,7,7

for (const key in {a: 1, b: 2}) {
  console.log(key);
}
// a,b

for (const value of [1, 2, 3, 4, 5]) {
  console.log(value);
}
// 1,2,3,4,5
```

## 3.6 声明风格最佳实践

1. 不使用var
2. const优先，let次之

## 3.7 数据类型

ECMAScript中有7中简单数据类型（也称为**原始类型**）：

- Undefined
- Null
- Boolean
- Number
- BigInt
- String
- Symbol

还有一种复杂数据类型叫Object.

Object是一种**无序**键值对的集合。

### typeof 操作符

因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：

- "undefined"表示未定义；
- "boolean"表示值为布尔值
- "string"表示值为字符串
- "number"表示值为数值
- "bigint"表示大整形
- "object"表示值为对象(而不是函数)或null
- "function"表示值为函数
- "symbol"表示值为符号

下面是使用typeof操作符的例子

```js
let message = "some string";
console.log(typeof message); // "string"
console.log(typeof(message)); // "string"
console.log(typeof 95); // "number"
```

在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，**因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）**。 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null 返回的是"object"。这是因为特殊值 null 被认为是一个对空对象的引用

> 注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

### Undefined类型

Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：

```js
let message;
console.log(message === undefied); // true
```

在这个例子中，变量 message 在声明的时候并未初始化。而在比较它和 undefined 的字面值时， 两者是相等的。这个例子等同于如下示例：

```js
let message = undefined;
console.log(message == undefined); // true 
```

这里，变量 message 显式地以 undefined 来初始化。但这是不必要的，因为默认情况下，任何未 经初始化的变量都会取得 undefined 值。

> 注意 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。

注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：

```js
let message;	// 这个变量被声明了，只是值是undefined

// 确保没有声明过这个变量
// let age

console.log(message); // "undefined"
console.log(age);			// 报错
```

在上面的例子中，第一个 console.log 会指出变量 message 的值，即"undefined"。而第二个 console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个 有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用， 实际上在严格模式下会抛出错误。）

在对未初始化的变量调用 typeof 时，返回的结果是"undefined"，但对未声明的变量调用它时， 返回的结果还是"undefined"，这就有点让人看不懂了。比如下面的例子：

```js
let message;	// 这个变量被声明了，只是值是undefined

// 确保没有声明过这个变量
// let age

console.log(typeof message); // "undefined"
console.log(typeof age);			// "undefined"
```

无论是声明还是未声明，typeof 返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然 严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。

> 即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的 同时进行初始化。这样，当 typeof 返回"undefined"时，你就会知道那是因为给定的变 量尚未声明，而不是声明了但未初始化。

undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多 其他可能的值同样是假值。所以一定要明确自己想检测的就是 undefined 这个字面值，而不仅仅是 假值。

```js
let message; // 这个变量被声明了，只是值为 undefined
// age 没有声明
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
}
if (age) {
 // 这里会报错
} 
```

### Null类型

Null类型同样只有一个值，就是特殊值null.逻辑上讲，null值表示一个空对象指针，这也是给typeof 传一个null会返回"object"的原因。

```js
let car = null;
console.log(typeof car);	// "object"
```

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：

```js
if (car != null) {
 // car 是一个对象的引用
} 
```

undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例 子所示：

```js
console.log(null == undefined); // true 
```

用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较 而转换它的操作数（本章后面将详细介绍）。

即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将 变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。

null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。

```js
let message = null;
let age;
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
} 
if (age) {
 // 这个块不会执行
}
if (!age) {
 // 这个块会执行
} 
```

### Boolean类型

Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。 这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。下面是给变量赋布尔值的例子：

```js
let found = true;
let lost = false;
```

注意，布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式） 是有效的标识符，但不是布尔值。

虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：

```js
let message = "Hello World";
let messageAsBoolean = Boolean(message);
console.log(messageAsBoolean); // true
```

在这个例子中，字符串message会被转换为布尔值并保存在变量messageAsBoolean中。

Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true 或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。

| 数据类型  | 转换为true的值       | 转换为false的值 |
| --------- | -------------------- | --------------- |
| Boolean   | true                 | false           |
| String    | 非空字符串           | ""(空字符串)    |
| Number    | 非零数值(包括无穷值) | 0, NaN          |
| BigInt    | 非零的任意值         | 0               |
| Object    | 任意对象             | null            |
| Undefined | ---                  | undefined       |

