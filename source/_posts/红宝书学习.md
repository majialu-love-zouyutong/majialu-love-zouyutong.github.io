---
title: 红宝书学习
date: 2025-06-16 21:11:11
tags: 红宝书 js
---

# 概述

1. 介绍JavaScript的起源：从哪里来，如何发展，以及现今的状况。这一章会谈到JavaScript与ECMAScript的关系，DOM，BOM，以及ECMA和W3C相关的标准。
2. 介绍JavaScript如何与HTML结合起来创建动态网页，主要介绍在网页中嵌入JavaScript的不同方式，还有JavaScript的内容类型及其与`<script>`元素的关系。
3. 介绍语言的基本概念，包括语法和流控制语句；解释JavaScript与其他类C语言在语法上的异同点。在讨论内置操作符时也会谈到强制类型转换。此外还将介绍所有的原始类型，包括Symbol。
4. 探索JavaScript松散类型下的变量处理。这一章将涉及原始类型和引用类型的不同，以及与变量有关的执行上下文。此外，这一章也会讨论JavaScript中的垃圾回收，涉及在变量超出作用域时如何回收内存。
5. 讨论JavaScript所有内置的引用类型。如Date， Regexp，原始类型及其包装类型。每种引用类型既有理论上的讲解，也有相关浏览器实现的剖析。
6. 继续讨论内置引用类型，包括Object，Array，Map，WeakMap，Set和WeakSet等。
7. 介绍ECMAScript新版中引入的两个基本概念：迭代器和生成器，并分别讨论他们最基本的行为和在当前语言环境下的应用。
8. 解释如何在JavaScript中使用类和面向对象编程。首先会深入讨论JavaScript的Object类型，进而探讨原型式继承，接下来全面介绍ES6类及其与原型式继承的紧密关系。
9. 介绍两个紧密相关的概念：Proxy(代理)和反射(Reflect)API。代理和反射用于拦截和修改这门语言的基本操作。
10. 探索JavaScript最强大的一个特性：函数表达式，主要涉及闭包，this对象，模块模式，创建私有对象成员，箭头函数，默认参数和扩展操作符。
11. 介绍两个紧密相关的异步编程构造：Promise类型和async/await。这一章讨论JavaScript的异步编程范式，进而介绍promise与异步函数的关系。
12. 介绍BOM，即浏览器对象模型，跟与浏览器本身交互的API相关。所有BOM对象都会涉及，包括window,document,location,navigator和screen等。
13. 解释检测客户端机器及其能力的不同手段，包括能力检测和用户代理字符串检测。这一章讨论每种手段的优缺点，以及适用场景。
14. 介绍DOM，即文档对象模型，主要是DOM Level 1定义的API。这一章将简单讨论XML及其与DOM的关系，进而全面探索DOM以及如何利用它操作网页。
15. 解释其他DOM API，包括浏览器本身对DOM的扩展，主要涉及Selectors API和Element Traversal API 和HTML5扩展。
16. 在之前两章的基础上，解释DOM Level 2和Level 3对DOM的扩展，包括新增的属性，方法和对象。这一章还会介绍DOM4的相关内容，比如Mutaion Observer。
17. 解释事件在JavaScript中的本质，以及事件的起源及其在DOM中的运行方式。
18. 围绕`<canvas>`标签讨论如何创建动态图形，包括2D和3D上下文(WebGL)等动画和游戏开发所需的基础。这一章还会讨论WebGL1和WebGL2.
19. 探索使用JavaScript增强表单交互及突破浏览器限制，主要讨论文本框，选择框等表单元素及数据验证和操作。
20. 介绍各种JavaScript API，包括Atomics，Encoding，File，Blob，Notifications，Streams，Timing，Web Components和Web Cryptography。
21. 讨论浏览器如何处理JavaScript代码中的错误及集中错误处理方式。这一章同时介绍了每种浏览器的调试工具和技术，包括简化调试过程的建议。
22. 介绍通过JavaScript读取和操作XML数据的特性，解释了不同浏览器支持特性和对象的差异，提供了简化跨浏览器编码的建议。这一章也讨论了使用XSLT在客户端转换XML数据。
23. 介绍作为XML替代的JSON数据格式，还讨论了浏览器原生解析和序列化JSON，以及适用JSON时要注意的安全问题。
24. 讨论浏览器请求数据和资源的常用方式，包括早期的XMLHttpRequest对象，以及现代的Fetch API。
25. 讨论应用程序离线时在客户端机器上存储数据的各种技术。先从cookie谈起，然后讨论Web Storage 和 IndexedDB。
26. 介绍模块模式在编码中的应用，进而讨论ES6模块之前的模块加载方式，包括CommonJS，AMD和UMD。最后介绍新的ES6模块及其正确用法。
27. 深入介绍专用工作者线程，共享工作者线程和服务工作者线程。其中包括工作者线程在操作系统和浏览器层面的实现，以及使用各种工作者线程的最佳策略。
28. 讨论在企业级开发中进行JavaScript编码的最佳实践。其中提到了提升代码可维护性的编码惯例，包括编码技巧，格式化及通用编码建议。深入讨论应用性能和提升速度的技术。最后介绍上线与部署相关的话题，包括项目构建流程。

# 第1章 什么是JavaScript

> 本章内容
> - JavaScript历史回顾
> - JavaScript是什么
> - JavaScript与ECMAScript的关系
> - JavaScript的不同版本

![20250616215345](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616215345.png)

> 这里这张图个人认为有点问题，DOM应该属于BOM，DOM是BOM的一部分，不应该和BOM并列。

ECMA-262到底定义了什么？
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 全局对象

## DOM

![20250616220143](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616220143.png)

![20250616220153](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250616220153.png)

### DOM级别

1998年10月，**DOM Level 1**成为W3C的推荐标准。该规范由两个模块组成：DOM Core和DOM HTML。前者提供了一种映射XML文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者，并增加了特定于HTML的对象和方法。

> 注意DOM并非只能通过JavaScript操作，也可以通过其他语言操作。不过对于浏览器来说，DOM就是使用ECMAScript实现的，如今已经成为JavaScript语言的一大组成部分。

DOM Level 1的目标是映射文档结构，而DOM Level2的目标则宽泛的多。增加了对鼠标和用户界面事件，范围，遍历（迭代DOM节点的方法）的支持，而且通过对戏那个接口支持了CSS。另外，DOM Level1 中的DOM Core也被扩展以包含对XML命名空间的支持。

**DOM Level 2**新增了以下模块：

- DOM视图：描述追踪文档不同视图（如应用CSS样式前后的文档）
- DOM事件：描述事件及事件处理的接口
- DOM样式：描述处理元素CSS样式的接口
- DOM遍历和范围：描述遍历和操作DOM树的接口

**DOM Level 3**增加了以统一方式加载和保存文档的方法(包含在DOM Load and Save新模块中)，还有验证文档的方法(DOM Validation)。在Level 3中，DOM Core模块被扩展，支持了所有XML1.0的特性，包括XML Infoset，XPath 和XML Base。

目前，W3C不再按照Level来维护DOM了，而是作为DOM Living Standard来维护，其快照成为DOM4. DOM4新增的内容包括替代Mutaion Events的Mutation Observers。

### 其他DOM

除了DOM Core和DOM HTML接口，其他语言也发布了自己的DOM标准，下面列出的语言是基于XML的，每一种都增加了该语言独有的DOM方法和接口。

- 可伸缩矢量图(SVG, Scalable Vector Graphics)
- 数学标记语言(MathML, Mathematical Markup Language)
- 同步多媒体集成语言(SMIL, Synchronized Multimedia Integration Language)

此外还有一些语言也开发了自己的DOM实现，比如Mozilla的XML用户界面语言(XUL, XML User Interface Language)，不过，只有前面列表中的语言是W3C推荐的标准。

## BOM

HTML5涵盖了尽可能多的BOM特性。

总体来说，BOM主要针对浏览器窗口和子窗口(frame)，不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如，下面就是这样一些扩展：

- 弹出新浏览器窗口的能力
- 移动，缩放和关闭浏览器窗口的能力
- navigator对象，提供关于浏览器的详尽信息
- location对象，提供浏览器加载页面的详尽信息
- screen对象，提供关于用户屏幕分辨率的详尽信息
- performance对象，提供浏览器内存占用，导航行为和事时间统计的详尽信息
- 对cookie的支持
- 其他自定义对象，如XMLHttpRequest

## 小结

JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。
- ECMAScript：由ECMA-262定义并提供的核心功能
- DOM：提供与网页内容交互的方法和接口
- BOM：提供与浏览器交互的方法和接口

# 第2章 HTML中的JavaScript

> 本章内容
> - 使用`<script>`元素
> - 行内脚本与外部脚本比较
> - 文档模式对JavaScript有什么影响
> - 确保JavaScript不可用时的用户体验

将JavaScript插入HTML的主要方法是使用`<script>`元素，这个元素已经被正式加入HTML规范。

`<script>`元素有下列8个属性：

- **src**：可选。表示包含要执行的代码的外部文件。
- **async**：可选。表示应该**立即开始下载脚本**，但是**不能阻止页面其他动作**，比如下载资源或等待其他脚本加载。只对外部脚本有效。
- charset：可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
- crossorigin：可选。配置相关请求的CORS(跨域资源共享)设置。默认不使用CORS。`crossorigin="anonymous"`配置文件请求不必设置凭据标志。`crossorigin="use-credentials"`设置凭据标志，意味着出站请求会包含凭据。
- **defer**：可选。表示**脚本可以延迟到文档完全被解析和显示之后再执行**。只对外部脚本有效。
- integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性(SRI, Subresource Integrity)。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可用于**确保CDN不会提供恶意内容**。
- language: 废弃。最初用于表示代码块中的脚本语言（如"JavaScript"、"JavaScript 1.2"
或"VBScript"）。大多数浏览器都会忽略这个属性，不应该再使用它。
- **type**：可选。代替language，表示代码块中脚本语言的类型(也称为MIME类型)。按照惯例，这个值始终都是"text/javascript".尽管"text/javascript"和"text/ecmascript"都已经废弃了。JavaScript的MIME类型是"application/x-javascript"，不过给type属性这个值可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。**如果这个值是module，则代码会被当做ES6模块，而且只有这时候，代码中才能出现import和export**。

使用`<script>`的方式有两种：
- 行内脚本：将脚本放在`<script>`元素的内容中。
- 外部脚本：将脚本放在外部文件中，并使用src属性将外部脚本引入HTML文档中。

浏览器解析行内脚本的方式决定了它在看到字符串`</script>`时，会将其当成结束的`</script>`标签。想避免这个问题，只需要传递转义字符`\`即可：

```html
  <script>
    console.log("<\/script>")
  </script>
```

> 注意：使用了src属性的`<script>`元素不应该在`<script>`和`</script>`之间包含其他JavaScript代码。如果两者都提供的话，浏览器只会下载并执行脚本文件，从而**忽略行内代码**。

> `<script>`标签的src属性可以引入外部域的脚本文件，不受浏览器同源策略的限制。
> 但是这个可能会导致安全问题，使用`<script>`标签的integrity属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持。

在没有使用`async`和`defer`的情况下，浏览器会按照`<script>`标签在页面中出现的顺序依次解释他们。

使用了`defer`的脚本会在浏览器解析到结束的`</html>`标签后才会执行。HTML5规范要求脚本应该按照他们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，**而且两者都在`DOMContentLoaded`事件之前执行。**

使用了`async`的脚本会在**页面的load事件之前执行，但可能会在DOMContentLoaded事件之前或之后执行**，而且**无法保证脚本的顺序**。所以，在async脚本中，不要对DOM进行操作。

## 动态加载脚本

除了`<script>`标签，还有其他方式可以加载脚本。因为JavaScript可以使用DOM API，所以通过DOM中动态添加script元素同样可以加载指定的脚本。只要创建一个script元素并将其添加到DOM即可。

```js
let script = document.createElement('script');
script.src = 'gibberish.js';
document.body.appendChild(script);
```
默认情况下，以这种方式创建的`<script>`元素是**异步加载**的，相当于添加了`async`属性。

以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响他们在资源获取队列中的优先级。这种方式可能会严重影响性能。要想让浏览器**预加载器**直到这些动态请求文件的存在，可以在文档头部显式声明他们：

```html
<link rel="preload" href="gibberish.js">
```

## 文档模式

IE5.5发明了文档模式的概念，即可以使用DOCTYPE来切换文档模式。最初的文档模式有两种：
- 怪异模式/混杂模式(quirks mode)
- 标准模式(standards mode)

在HTML文件中第一行的代码，目的就是告诉浏览器使用标准模式解析文档，不要使用怪异模式。

```html
<!DOCTYPE html>
```

## `<noscript>`元素

针对早期浏览器不支持 `JavaScript` 的问题，需要一个页面优雅降级的处理方案。最终，`<noscript>`
元素出现，被用于给不支持 `JavaScript` 的浏览器提供替代内容。虽然如今的浏览器已经 100%支持
JavaScript，但对于禁用 `JavaScript` 的浏览器来说，这个元素仍然有它的用处。
`<noscript>`元素可以包含任何可以出现在`<body>`中的 HTML 元素，`<script>`除外。在下列两种
情况下，浏览器将显示包含在`<noscript>`中的内容：

- 浏览器不支持脚本
- 浏览器对脚本的支持被关闭

任何一个条件被满足，包含在`<noscript>`中的内容就会被渲染。否则，浏览器不会渲染`<noscript>`中的内容。

```html
<!DOCTYPE html>
<html>
 <head>
 <title>Example HTML Page</title>
 <script defer="defer" src="example1.js"></script>
 <script defer="defer" src="example2.js"></script>
 </head>
 <body>
 <noscript>
 <p>This page requires a JavaScript-enabled browser.</p>
 </noscript>
 </body>
</html> 
```

# 第3章 语言基础

## 3.1 语法

1. 变量名区分大小写
2. 标识符：变量，函数，属性或函数参数的名称：
  - 第一个字符必须是字母，下划线，或美元符
  - 后续字符可以是字母，数字，下划线，或美元符
标识符中的字母可以是扩展ASCII(Extended ASCII)中的字母，也可以是Unicode的字母字符。

## 3.2 严格模式

ECMAScript 5 引入了严格模式(strict mode)。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

可以在整个文件或某个函数中开启严格模式，只需要加上`"use strict";`

```js
"use strict"
```

```js
function doSomething() {
  "use strict"
  // 函数体
}
```

## 3.3 分号插入

在JavaScript中，分号`;`是可选的，但是为了避免错误，还是建议加上分号。

## 3.4 关键字与保留字

![20250625182346](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250625182346.png)

![20250625182415](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250625182415.png)

这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字
和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。

## 3.5 变量

ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6 及更晚的版本中使用。

| 关键字   | `var`                       | `let`                       | `const`                                            |
| -------- | --------------------------- | --------------------------- | -------------------------------------------------- |
| 作用域   | 函数作用域                  | 块级作用域                  | 块级作用域                                         |
| 初始化   | 可以不初始化，值为undefined | 可以不初始化，值为undefined | 必须初始化                                         |
| 提升     | 提升到函数作用域顶部        | TDZ暂时性死区               | TDZ暂时性死区                                      |
| 重复声明 | 后者覆盖前者                | ReferenceError              | ReferenceError                                     |
| 重复赋值 | 更新为新值                  | 更新为新值                  | 重新赋值会导致运行时错误，但是可以改变对象的属性值 |
| 全局声明 | 称为window对象的属性        | 不会挂载到全局对象          | 不会挂载到全局对象                                 |

## for循环中的let声明

在let出现之前，**for循环定义的迭代变量会渗透到循环体外部**：

```js
for (var i = 0; i < 5; i++) {
  // 循环逻辑
}
console.log(i); // 5
```

改用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块的内部：

```js
for (let i = 0; i < 5; i++) {
  // 循环逻辑
}
console.log(i);	// ReferenceError：i is not defined
```

在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改：

```js
for (var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

你可能以为会输出0,1,2,3,4

实际上会输出5,5,5,5,5

之所以会这样，是因为在退出循环时，迭代变量保存的是**导致循环退出的值**：5.在之后执行超时逻辑时，所有的i使用的都是同一个变量，因为输出的都是同一个最终值。

而在使用let声明迭代变量时，JavaScript在后台会**为每个迭代循环声明一个新的迭代变量**。每个`setTimeout`引用的都是不同的变量实例，所以`console.log`输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。

```js
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 0);
}
// 输出 0,1,2,3,4
```

这种每次迭代声明一个独立变量实例的行为适用于**所有风格的for循环**。包括`for-in`和`for-of`循环。

JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，虽然const变量跟let变量很相似，但是不能用const来声明迭代变量（因为迭代变量会自增）

```js
for (const i = 0; i < 10; i++)	// TypeError: Assignment to constant variable
```

不过，可以用const声明一个不会被修改的for循环变量。也就是说，每次迭代只是创建一个新变量。这对`for-of`和`for-in`循环特别有意义。

```js
let i = 0;
for (const j = 7; i < 5; i++) {
  console.log(j);
}
// 7,7,7,7,7

for (const key in {a: 1, b: 2}) {
  console.log(key);
}
// a,b

for (const value of [1, 2, 3, 4, 5]) {
  console.log(value);
}
// 1,2,3,4,5
```

## 3.6 声明风格最佳实践

1. 不使用var
2. const优先，let次之

## 3.7 数据类型

ECMAScript中有7中简单数据类型（也称为**原始类型**）：

- Undefined
- Null
- Boolean
- Number
- BigInt
- String
- Symbol

还有一种复杂数据类型叫Object.

Object是一种**无序**键值对的集合。

### typeof 操作符

因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：

- "undefined"表示未定义；
- "boolean"表示值为布尔值
- "string"表示值为字符串
- "number"表示值为数值
- "bigint"表示大整形
- "object"表示值为对象(而不是函数)或null
- "function"表示值为函数
- "symbol"表示值为符号

下面是使用typeof操作符的例子

```js
let message = "some string";
console.log(typeof message); // "string"
console.log(typeof(message)); // "string"
console.log(typeof 95); // "number"
```

在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，**因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）**。 注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null 返回的是"object"。这是因为特殊值 null 被认为是一个对空对象的引用

> 注意 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

### Undefined类型

Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：

```js
let message;
console.log(message === undefied); // true
```

在这个例子中，变量 message 在声明的时候并未初始化。而在比较它和 undefined 的字面值时， 两者是相等的。这个例子等同于如下示例：

```js
let message = undefined;
console.log(message == undefined); // true 
```

这里，变量 message 显式地以 undefined 来初始化。但这是不必要的，因为默认情况下，任何未 经初始化的变量都会取得 undefined 值。

> 注意 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。

注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：

```js
let message;	// 这个变量被声明了，只是值是undefined

// 确保没有声明过这个变量
// let age

console.log(message); // "undefined"
console.log(age);			// 报错
```

在上面的例子中，第一个 console.log 会指出变量 message 的值，即"undefined"。而第二个 console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个 有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用， 实际上在严格模式下会抛出错误。）

在对未初始化的变量调用 typeof 时，返回的结果是"undefined"，但对未声明的变量调用它时， 返回的结果还是"undefined"，这就有点让人看不懂了。比如下面的例子：

```js
let message;	// 这个变量被声明了，只是值是undefined

// 确保没有声明过这个变量
// let age

console.log(typeof message); // "undefined"
console.log(typeof age);			// "undefined"
```

无论是声明还是未声明，typeof 返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然 严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。

> 即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的 同时进行初始化。这样，当 typeof 返回"undefined"时，你就会知道那是因为给定的变 量尚未声明，而不是声明了但未初始化。

undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多 其他可能的值同样是假值。所以一定要明确自己想检测的就是 undefined 这个字面值，而不仅仅是 假值。

```js
let message; // 这个变量被声明了，只是值为 undefined
// age 没有声明
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
}
if (age) {
 // 这里会报错
} 
```

### Null类型

Null类型同样只有一个值，就是特殊值null.逻辑上讲，null值表示一个空对象指针，这也是给typeof 传一个null会返回"object"的原因。

```js
let car = null;
console.log(typeof car);	// "object"
```

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：

```js
if (car != null) {
 // car 是一个对象的引用
} 
```

undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例 子所示：

```js
console.log(null == undefined); // true 
```

用等于操作符（==）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较 而转换它的操作数（本章后面将详细介绍）。

即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将 变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。

null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可 能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值。

```js
let message = null;
let age;
if (message) {
 // 这个块不会执行
}
if (!message) {
 // 这个块会执行
} 
if (age) {
 // 这个块不会执行
}
if (!age) {
 // 这个块会执行
} 
```

### Boolean类型

Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。 这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。下面是给变量赋布尔值的例子：

```js
let found = true;
let lost = false;
```

注意，布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式） 是有效的标识符，但不是布尔值。

虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：

```js
let message = "Hello World";
let messageAsBoolean = Boolean(message);
console.log(messageAsBoolean); // true
```

在这个例子中，字符串message会被转换为布尔值并保存在变量messageAsBoolean中。

Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true 或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。

| 数据类型  | 转换为true的值       | 转换为false的值 |
| --------- | -------------------- | --------------- |
| Boolean   | true                 | false           |
| String    | 非空字符串           | ""(空字符串)    |
| Number    | 非零数值(包括无穷值) | 0, NaN          |
| BigInt    | 非零的任意值         | 0               |
| Object    | 任意对象             | null            |
| Undefined | ---                  | undefined       |

### Number类型

Number类型使用IEEE754格式表示整数和浮点数。

最基本的是十进制，直接写出来即可。

```js
let intNum = 55;
```

整数也可以使用8进制，或16进制。

- 8进制：以0o开头，然后是相应的的八进制数字(0-7)，如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制，如下所示：

```js
let octalNum1 = 0o70;		// 八进制的56
let octalNum2 = 0o79;		// 无效的八进制，当成十进制的79处理
let octalNum3 = 0o8;			// 无效的八进制，当成十进制的8处理
```

> 八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。

- 16进制：以0x(区分大小写)开头，然后是16进制的数字(0-9,A-F).16进制中数字中的字母大小写均可。下面是例子：

```js
let hexNum = 0xA;		// 十六进制10
let hexNum = 0x1f;	// 十六进制31
```

使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。

#### 浮点值

要定义浮点值，数值中必须包含小数点，且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。

```js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1;		// 有效，但不推荐
```

因为存储浮点数使用的内存空间是存储整数值的**两倍**，所以ECMAScript总是想方设法把值转换为整数。

> 在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着0(如1.0)，那它也会被转换为整数。

```js
let floatNum1 = 1.;		// 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0;	// 小数点后面是0，当成整数10处理
```

对于非常大或者非常小的数值，浮点值可以用科学计数法来表示。

```js
let floatNum = 3.1235e7;		// 等于31250000
```

> 0.1 + 0.2 !== 0.3

> 永远不要测试某个浮点数的值！！！

#### 值的范围

由于内存限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN_VALUE中，这个值在大多数浏览器中是5e-324;可以表示的最大数值保存在Nubmer.MAX_VALUE中，这个值在多数浏览器中是1.7976931348623157e+308.

如果某个计算得到的结果超出了JavaScript可以表示的范围，那么这个数值会被**自动转换为一个特殊的Infinity(无穷值)**.任何无法表示的负数以-Infinity来表示，任何无法表示的正数以Infinity来表示。

如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的 最小值和最大值之间），可以使用 `isFinite()`函数，如下所示：

```js
let result = Number.MIN_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false
```

在计算非常大和非常小的数的时候，有必要检测一下是否超出范围。

#### NaN

有一个特殊的数值叫NaN，意思是“不是数值”(Not a Number)，用来表示本来要返回数值的操作失败了(而不是抛出错误).比如，用0除任意数值在其他语言中通常会导致错误，从而终止代码执行。但在ECMAScript中，0,+0,-0相除会返回NaN.

```js
console.log(0 / 0);
console.log(-0 / +0);
console.log(5 / 0);
console.log(5 / -0);
console.log(0 / 3);

// NaN
// NaN
// Infinity
// -Infinity
// 0
```

NaN有几个独特的属性：

1. 任何涉及NaN的操作始终返回NaN(例如NaN/10).
2. NaN不等于包括NaN在内的任何值。

```js
console.log(NaN == NaN);	// false
```

为此，ECMAScript设置了`isNaN()`函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给`isNaN()`后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换为数值，例如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下：

```js
console.log(isNaN(NaN));  // true
console.log(isNaN(10));   // false，转换为数值10
console.log(isNaN("10")); // false,转换为数值10
console.log(isNaN("10.33"));  // false，转换为数值10.33
console.log(isNaN("blue"));   // true,不能转换为数值
console.log(isNaN(true));     // false，转换为数值1
console.log(isNaN(false));    // false，转换为数值0
```

> NaN也可以用来测试对象。对象会首先调用`[Symbol.toPrimitive]()`方法,如果未定义，则接着调用`valueOf()`方法，然后再确定返回的值能否转换为数值。如果不能，再调用`toString()`方法，并测试其返回值。

```js
let obj = {
  [Symbol.toPrimitive](hint) {
    if (hint === "string") return "Hello";
    if (hint === "number") return 100;
    return "default";
  }
};
console.log(String(obj)); // "Hello"（hint="string"）
console.log(+obj);        // 100（hint="number"）
console.log(obj + "");    // "default"（hint="default"）
```

#### 数值转换

有3个函数可以将非数值转换为数值：`Number()`,`parseInt()`,`parseFloat()`。`Number`是转型函数，可以用于任何数据类型。后两个函数主要用于将**字符串转换为数值**。对于同样的参数，这3个函数执行的操作也不同。

Number()函数基于如下规则进行转换：

- 布尔值，true转换为1，false转换为0

- 数值，直接返回

- null，返回0

- undefined，返回NaN

- 字符串，应用如下规则：

  - 如果字符串包含数值字符，包括数值字符前面带加减号的情况，则转换为一个十进制数值。

    因此，Number("1")返回1，Number("123")返回123，Number("011")返回11(忽略前面的0)

  - 如果字符串包含有效的浮点值格式如“1.1”，则会转换为相应的浮点值(同样，忽略前面的零)
  
  - 如果字符串包含有效的十六进制格式如“0xf"，则会转换为与该十六进制对应的十进制整数值
  
  - 如果是空字符串(不包含字符)则返回0
  
  - 如果字符串包含上述情况之外的字符，则返回NaN
  
- 对象，依次调用`[Symbol.toPrimitive]()`,`valueOf()`,`toString()`方法，并按照上述规则转换返回的值。

> 一元加操作符与Number()函数遵循相同的转换规则

考虑到用Number函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时，可以优先使用`parseInt()`函数。`parseInt()`函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符，加号或减号，`parseInt()`立即返回`NaN`。这意味着空白字符串也会返回NaN(这一点跟Number()不一样，Number返回0)。如果第一个字符是数值字符，加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如"1234blue"会被转换为1234.因为blue会被完全忽略。类似的"22.5"会被转换为22,因为小数点不是有效的整数字符。

假设字符串中的第一个字符是数值字符，`parseInt()`函数也能识别不同的整数格式(十进制，十六进制).换句话说，如果字符串以"0x"开头，就会被解释为16进制整数。

```js
let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10，解释为十六进制整数
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70，解释为十进制值
let num6 = parseInt("0xf"); // 15，解释为十六进制整数
```

不同的数值格式很容易混淆，因此`parseInt()`也接受第二个参数，用于指定底数(进制数)。如果直到要解析的是16进制，那么可以传入16作为第二个参数，以便正确解析。

```js
let num = parseInt("0xAF", 16);	// 175
let num1 = parseInt("AF", 16);	// 175
let num2 = parseInt("AF");		// NaN
```

在这个例子中，第一个转换是正确的，而第二个转换失败了。区别在于第一次传入了进制数作为参 数，告诉 parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字 符，随即自动停止并返回 NaN。

`parseFloat()`函数的工作方式跟`parseInt()`函数类型，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但是第二次出现的小数点就无效了，此时字符串中剩余字符都会被忽略。因此，"22.34.5"将会被转换为22.34。

`parseFloat()`函数的另一个不同之处在于，它始终忽略字符串开头的0.这个函数能识别前面讨论的所有浮点格式，以及十进制格式(开头的0将会被忽略)。十六进制数值始终会返回0.因为`parseFloat()`直解析十进制值，因此不能指定底数。最后，如果字符串表示整数(没有小数点或者小数点后面只有一个零),则`parseFloat()`返回整数。

```js
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); // 31250000 
```

### String类型

String数据类型表示0或多个16位Unicode字符序列。字符串可以使用双引号，单引号或反引号标识。

```js
let firstName = "John";
let lastName = "Jacob";
let lastName = `Jingleheimershcmidt`
```

引号的开头和结尾要匹配，使用同一种引号

```js
let firstName = 'lksdjfkljds";	// 语法错误
```

#### 字符串字面量

| 字面量   | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| `\n`     | 换行                                                         |
| `\t`     | 制表                                                         |
| `\b`     | 退格                                                         |
| `\r`     | 回车                                                         |
| `\f`     | 换页                                                         |
| `\\`     | 反斜杠                                                       |
| `\'`     | 单引号，在字符串以单引号标示时使用，例如`'He said, \'hey.\''` |
| `\"`     | 双引号，在字符串以双引号标示时使用，例如`"He said, \"hey.\""` |
| \\`      | 反引号，在字符串以双引号标示时使用.                          |
| `\xnn`   | 以十六进制编码nn表示的字符(其中n是十六进制数字0-F),例如`\x41`等于"A" |
| `\unnnn` | 以十六进制nnnn表示的Unicode字符                              |

这些字符字面量可以出现在字符串中的任意位置，**且可以作为单个字符被解释**：

```js
 let text = "This is the letter sigma: \u03a3.";
```

在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。字符串的长度可以通过其 length 属性获取： console.log(text.length); // 28 这个属性返回字符串中 16 位字符的个数。

|        **返回值**        |     **属性/方法**     |          **适用场景**          |
| :----------------------: | :-------------------: | :----------------------------: |
|     UTF-16 码元数量      |    `string.length`    | 基础字符串操作（需注意代理对） |
|   实际字符数（码点数）   |   `[...str].length`   | 精确字符统计（含辅助平面字符） |
| 物理字节数（需指定编码） | `Buffer.byteLength()` |     网络传输、存储空间计算     |

#### 字符串特点

ECMAScript中的字符串是不可变的(immutable)，意思是一旦创建，他们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：

```js
let lang = "Java";
lang = lang + "Script";
```

这里，变量 lang 一开始包含字符串"Java"。紧接着，lang 被重新定义为包含"Java"和"Script" 的组合，也就是"JavaScript"。

整个过程会首先分配一个足够容纳10个字符的空间，然后填充上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script",因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如 Firefox 1.0 之前的版本和 IE6.0）在 拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题。

#### 转换为字符串

有两种方式把一个值转换为字符串。首先是几乎所有值都有的`toString()`方法。这个方法唯一的作用就是返回当前值的字符串等价物。

```js
let age = 11;
let ageAsString = age.toString();	// 字符串"11"
let found = true;
let foundAsString = found.toString();	// 字符串"true"
```

`toString()`方法可见于数值，布尔值，对象和字符串值(没错，字符串也有toString()方法，该方法只是简单地返回自身的一个副本)。

null和undefined没有`toString()`方法。

多数情况下，`toString()`方法不接收任何参数。不过，在数值调用这个方法时，可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，`toString()`返回数值的十进制字符串表示。可以通过传入参数修改。

```js
let num = 10;
num.toString();			// "10"
num.toString(2);		// "1010"
num.toString(8);		// "12"
num.toString(10);		// "10"
num.toString(1)
```

