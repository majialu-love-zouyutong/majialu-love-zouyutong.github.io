---
title: 【代码随想录刷题总结】leetcode1047-删除字符串中的所有相邻重复项
date: 2025-07-14 20:53:00
tags: 代码随想录 leetcode 栈 队列
categories: leetcode
top_img: /img/leetcode.png
cover: /img/leetcode.png
---

## 引言

大家好啊，我是前端拿破轮😁。

跟着卡哥学算法有一段时间了，通过[代码随想录](https://programmercarl.com/)的学习，受益匪浅，首先向卡哥致敬🫡。

但是在学习过程中我也发现了一些问题，很多当时理解了并且AC的题目过一段时间就又忘记了，或者不能完美的写出来。根据**费曼学习法**，光有输入的知识掌握的是不够牢靠的，所以我决定**按照代码随想录的顺序，输出自己的刷题总结和思考**。同时，由于以前学习过程使用的是`JavaScript`,而在2025年的今天，`TypeScript`几乎成了必备项，所以本专题内容也将使用`TypeScript`，来巩固自己的`TypeScript`语言能力。

## 题目信息

删除字符串中的所有相邻重复项

[leetcode题目链接](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 s 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。


## 题目分析

本题同样符合**后进先出(LIFO)**的特点。从左往右扫描字符串的过程中，后扫描到的字符会先被消除。并且也有两两配对的需求。所以是典型的栈的应用。

从左往右依次扫描字符串，如果当前栈非空并且栈顶元素和当前元素相等，则将栈顶元素弹出；否则将当前元素压入栈中。最后返回栈中元素组成的字符串即可。

## 题解

```ts
function removeDuplicates(s: string): string {
    // 辅助栈
    const stack = [];

    // 遍历字符串
    for (let c of s) {
        // 如果栈中非空，并且栈顶元素等于当前元素，则弹出栈顶元素
        if (stack.length && stack[stack.length - 1] === c) {
            stack.pop();
        } else {
            // 否则将当前元素入栈
            stack.push(c);
        }
    }

    // 最后将辅助栈中的元素拼接为字符串返回
    return stack.join('');
};
```

时间复杂度: $O(N)$，只遍历一次字符串。

空间复杂度: $O(N)$，需要问题规模的辅助栈。

## 总结

本题是栈的典型应用之一，类似消消乐的方式体现了LIFO的特点。题目比较简单，注意代码细节即可。

好了，这篇文章就到这里啦，如果对您有所帮助，欢迎点赞,收藏,分享👍👍👍。您的认可是我更新的最大动力。由于笔者水平有限，难免有疏漏不足之处，欢迎各位大佬评论区指正。

> 往期推荐✨✨✨
> - [不是吧不是吧，2025年了还有人不会括号匹配？](https://juejin.cn/post/7526798996633813002)
> - [腾讯面试官：听说你在字节面试用栈实现队列，那怎么用队列实现栈呢](https://juejin.cn/post/7526646508784173083)
> - [字节面试官：用栈给我实现一个队列😏😏😏](https://juejin.cn/post/7526553055778750515)
> - [CJS和ESM两种模块化标准的异同分析](https://juejin.cn/post/7473814041867780130)
> - [🤔5202年了，你不会还不知道WebAssembly吧？](https://juejin.cn/post/7498988293209784374)
> - [🚀🚀🚀实在受不了混乱的提交——我使用了commitlint和commitizen](https://juejin.cn/post/7508919522905522226)
> - [当我用deepwiki来学习React源码](https://juejin.cn/post/7514876424806334504)
> 

我是前端拿破轮，关注我，一起学习前端知识，我们下期见！
