---
title: 随笔小记
date: 2024-12-11 13:23:28
tags: 随笔
---

# JS

## 关于矩阵的创建

今天做了一个 leetcode 的 59 螺旋矩阵题目，该题在最开始需要创建一个矩阵。GPT 给的方式如下

```js
const matrix = Array.from({ length: n }, () => Array(n).fill(0));
```

这个代码片段使用了 ES6 的 Array.from()方法，该方法接受一个可迭代对象（通常是一个类数组对象）作为参数，并返回一个新数组。其中第二个参数是一个映射函数，用于将每个元素映射到新数组中的元素。

这个代码片段中，{ length: n }是一个对象，它表示创建一个长度为 n 的数组。然后，Array(n)是一个数组，它表示创建一个包含 n 个 0 的数组。最后，fill(0)是一个数组方法，它将数组中的每个元素设置为 0。

我过去创建矩阵通常使用如下方法

```js
const matrix = new Array(n).fill(0).map(() => new Array(n).fill(0));
```

这个代码片段首先创建了一个长度为 n 的数组，每个元素都被设置为 0。然后，它使用 map()方法将每个元素转换为一个新的数组，并使用 fill(0)方法将每个数组中的元素设置为 0。

这里在使用第二种方法时,很容易出现**共享引用**的错误.

错误示例：

```javascript
const result = new Array(n).fill(new Array(n).fill(0));
```

这里 fill 用的是同一个子数组引用，导致所有行指向同一个数组。
修改其中一个子数组会影响其他行：

```javascript
result[0][0] = 1;
console.log(result);
// 输出:
// [
// [1, 0, 0],
// [1, 0, 0],
// [1, 0, 0]
// ]
```

> 总结
> Array.from 推荐: 更安全且代码简洁，避免引用共享问题。
> fill + map: 同样有效，适合对 map 方法较为熟悉的开发者。
> 切记，**不能用 fill 填充同一个子数组引用**，否则会产生意外的共享引用问题。

# hexo 个人博客

## 关于图片引用问题
### 文章图片本地和远程不能同时显示问题
### 文章的top_img和cover路径问题