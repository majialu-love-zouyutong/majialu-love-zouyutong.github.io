---
title: 小米24秋招
date: 2025-05-10 12:01:37
tags: 小米 笔试
cover: /img/xiaomi.png
top_img: /img/xiaomi.png
---

# 试卷分析


# 逐题讲解

## 题目1

Git暂存操作的API是什么？

![20250510120500](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510120500.png)

> git命令
> [学习git小游戏](https://learngitbranching.js.org/?locale=zh_CN)

> 正确答案： B

A. `git bisect`是利用二分法思想，查找是哪一次提交引入了错误
B. `git stash`是暂存操作
C. `git rebase`是变基操作
D. `git fetch`是拉取远程分支，但是不合并的操作。

---
## 题目2

[]的valueOf和toString的结果是什么？

![20250510120842](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510120842.png)

> 正确答案： A

> JS 引用类型向基本类型的转换

> [原始值强制转换](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive)用于得到期望的原始值，但对实际的类型应该是什么并没有强烈的偏好。通常情况下，可以接受string,number或BigInt。
> 转换规则如下：
> 如果值已经是原始值（number,bigint,string,symbol,boolean,null,undefined），则此操作不会进行任何转换。
> 如果是对象，则会依次调用它的`[Symbol.toPrimitive]()`（将`default`作为hint值），`valueOf()`和`toStirng()`方法，将其转换为原始值。注意，原始值转换会在 `toString()` 方法之前调用 `valueOf()` 方法，这与 number 强制转换的行为相似，但与字符串强制转换不同。
> 如果`[Symbol.toPrimitive]()`方法存在，必须返回原始值，如果返回对象，会导致`TypeError`。对于`valueOf()`和`toString()`，如果其中一个返回对象，则忽略其返回值，从而返回另一个的返回值；如果两者都不存在，或者两者都没有返回原始值，则抛出`TypeError`。

例如：在下面的代码中
```js
console.log({} + []); // [object Object]
```
`{}`和`[]`都没有`[Symbol.toPrimitive]()`方法。`{}`和`[]`都从`Object.prototype.valueOf`继承`valueOf()`，其返回对象自身。因为返回值是对象，所以它被忽略。因此，调用`toString()`方法。`{}.toString()`返回`[object Ojbect]`，而`[].toString()`返回空字符串`""`，因此结果是两个字符串相加`"[object Object]"`.

在强制转换为任意的原始类型时，[Symbol.toPrimitive]() 方法总是优先调用。原始值强制转换的行为通常与 number 强制转换类似，因为优先调用了 valueOf()；然而，有着自定义 [Symbol.toPrimitive]() 方法的对象可以选择返回任意的原始值。Date 和 Symbol 对象是唯一重写 [Symbol.toPrimitive]() 方法的对象。Date.prototype[Symbol.toPrimitive]() 将 "string" 视为 "default" hint，而 Symbol.prototype[Symbol.toPrimitive]() 忽略 hint 并始终返回一个 symbol。

你可能已经注意到，有三种不同的路径可以将对象转换为原始值：

原始值强制转换：[Symbol.toPrimitive]("default") → valueOf() → toString()
数字类型强制转换、number 强制转换、BigInt 强制转换：[Symbol.toPrimitive]("number") → valueOf() → toString()
字符串强制转换：[Symbol.toPrimitive]("string") → toString() → valueOf()

---

## 题目3

排序算法中哪一种算法的时间复杂度是`O(nlogn)`?

![20250510121211](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510121211.png)

> 正确答案： B

> 算法 排序

![20250511152934](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511152934.png)


---
## 题目4

通常情况下，一个URL的格式是

![20250510121509](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510121509.png)

> 正确答案： C

> 计算机网络 URL

一个完整的URL格式由多个层级组件构成，其核心结构可概括为以下部分（以HTTP协议为例）

```markdown
protocol://[username:password@]hostname[:port]/path/[;parameters][?query][#fragment]
```
其中中括号[]内的内容表示可选

1. 协议（Protocol）

定义资源访问方式，常见的协议包括：

- HTPP/HTTPS：网页传输协议，其中HTTPS增加了SSL/TLS加密层
- FTP：文件传输协议
- mailto：邮件客户端协议（如`mailto:user@example.com`）
- fiel：本地文件协议（如`file:///C:/doc.txt`）

2. 认证信息（可选）

部分场景需要用户名和密码，格式为`username:password@`（如访问私有FTP资源）

3. 主机（Host）

- 子域名：如`www`, `blog`等
- 主域名：如`tencent`,`google`等
- 顶级域（TLD）：如`.com`商业，`.org`（非盈利），`.cn`（国家代码）
- IP地址：直接使用数字地址代替域名，如`192.168.1.1`

4. 端口（Port，可选）

指定服务器端口，默认根据协议自动填充（如HTTP默认80，HTTPS默认443）。若使用非标准端口需要显式声明（比如我们前端用http协议访问本地开发服务器`http://example.com:8080`）

5. 路径（Path）

描述资源在服务器上的层级位置，由斜杠分隔

- 目录结构：如`/docs/tutorial`
- 文件名/Slug：如`article.html`

6. 参数（Parameters，可选）

以分号分隔的服务器端参数，如`https://example.com/file;type=pdf;security=high`

7. 查询字符串（Query，可选）

以`?`开头，传递动态参数，键值对用`&`连接：
示例`?page=1&sort=price`

8. 片段，也叫哈希标识（Fragment，可选）

以`#`开头，定位页面内锚点（如`#chapter3`）

> 注意：URL只能显示ASCII字符集中的**可显示字符**，非ASCII字符（如中文，表情符号，特殊符号等）必须通过编码转换成ASCII格式才能使用。

---

## 题目5

以下哪个项目不是可以在HTML文档中使用的特殊字符

![20250510124921](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510124921.png)

> 正确答案：B

> HTML实体

本题考察的是HTML实体的概念，有一些字符由于是HTML的保留字，所以不能直接在HTML中使用，需要使用实体替代。
A选项应该是已经使用了实体`&gt;`，在页面上解析为大于（greater than）
B选项写错了，小于号对应的实体是`&lt;`（less than）
C选项应该是`&copy;`
D选项是`&nbsp;`，不换行的空格（no breaking space）

[HTML实体](https://developer.mozilla.org/zh-CN/docs/Glossary/Entity)时一段以连字号(`&`)开头，以分号(`;`)结尾的文本（字符串）。HTML实体通常用于显示保留字符（这些字符会被解析为HTML代码）和不可见字符（如“不换行的空格”）。也可以使用HTML实体来代替其他难以用标准键盘键入的字符。

---
## 题目6

CSS权重顺序正确的是

![20250510125509](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510125509.png)

> 正确答案：C

> CSS选择器的特定性

---

## 题目7

面向对象编程设计的特点不包括：

![20250510125726](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510125726.png)

> 正确答案： A

> 软件工程 面向对象

面向对象的编程设计包括：抽象，封装，继承和多态。

---

题目8

网络七层协议不包括

![20250510125938](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510125938.png)

> 正确答案：B

> 计算机网络 网络参考模型

OSI参考模型有7层，从上到下分别是：
- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

---
## 题目9（多选）

关于JavaScript下列说法错误的是：

![20250510130253](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250510130253.png)

> 正确答案：BD

> JS 语言特性

A. JS区分大小写。
B. 标识符必须以字母，下划线或美元符开头，**不能以数字开头**。
C. JavaScript分号可以不加，因为有ASI(Automatic Semicolon Insertion, ASI)规则，在解析代码时自动补充缺失的分号。

> ASI(Automatic Semicolon Insertion, ASI)规则，在解析代码时自动补充缺失的分号。其核心规则包括：
> 1. 换行符触发：当换行符到吃当前语句无法正确解析时，自动插入分号（如`return`后换行）
> 2. 代码块结尾：在`{}`后自动补充分号，如函数或条件语句的结束位置
> 3. 文件末尾：在程序结束时会自动补充分号。
> 必须显式添加分号的情况：
1. 以特定字符开头的语句：若下一行以`(`,`[`,`/`,`+`,`-`开头，ASI可能无法识别语句边界，导致代码合并解析错误。
```js
// 错误解析为a = b[1,2].forEachh(..)
const a = b
[1,2].forEach(console.log)
```
2. 控制语句中的换行：`return`,`throw`,`break`,`continue`若这些关键字后直接换行，ASI会在其末尾直接插入分号，导致后续代码被忽略。

```js
// 错误：返回 undefined
return
{ a: 1 }

// 正确：保持同一行
return { a: 1 }
```
3. 自增/自减运算符(`++`,`--`)：若运算符在换行后，可能被解析为前缀而非后缀操作。

```js
// 错误：解析为 a; ++b;
a
++b
```
---

## 题目10
下边这代码输出的结果是
```js
const one = 0.1
const two = 0.2
const three = 0.3
console.log([two - one == one, three - two == one])
```
![20250511091933](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511091933.png)

> 计算机组成原理 浮点数存储方式

JS里面的number数据类型使用64位存储方式（IEEE754标准）。

- 1位用于表示符号（sign）（正数或负数）
- 11位用于表示指数（exponent）（-1022到1023）
- 52位用于表示尾数（mantissa）（表示0和1之间的数值）



---

## 题目11

Chrome浏览器都有哪些进程？

![20250511092043](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511092043.png)

> 正确答案：ABC

> Chrome

---


## 题目12
下面返回结果为true的有

![20250511092652](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511092652.png)

> 正确答案：AD
> JS isNaN()

isNaN() 函数用来确定一个值是否为 NaN，若有必要，则首先将值转换为数字。由于 isNaN() 函数内部的强制类型转换可能令人迷惑，因此你可能更想要使用 Number.isNaN()。

如果给定值在被转换为数字后为 NaN 则返回值为 true；否则为 false。

isNaN() 是全局对象的一个函数属性。

对于数字值，isNaN() 检测该值是否为 NaN 值。当 isNaN() 函数的参数不是数字类型时，其会首先被转换为数字，然后将其结果值与 NaN 进行比较。

isNaN() 对于非数字参数的行为可能会令人困惑！例如，空字符串被强制转换为 0，布尔值被强制转换为 0 或 1；直观上，两者均“不是数字”，仅因它们的运算结果不是 NaN，而使得 isNaN() 返回 false。因此，isNaN() 既不回答“输入是否为浮点数值 NaN”，也不回答“输入是否为数字”这两个问题。

Number.isNaN() 是检测一个值是否为数字值 NaN 的更可靠的方法。或者，也可以使用表达式 x !== x，这两种方法都不会产生全局 isNaN() 不可靠的误判。要检测一个值是否为数字，请使用 typeof x === "number"。

isNaN() 函数回答的问题是“在数字上下文中，输入是否在功能上与 NaN 等价”。如果 isNaN(x) 返回 false，则可以在算术表达式中使用 x，就好像它是一个有效的数字，而不是 NaN。如果 isNaN(x) 返回 true，则 x 将被强制转换为 NaN，并使大多数算术表达式返回 NaN（因为 NaN 会传播）。例如，可以使用这种方法来测试函数的参数是否可以进行算术处理（像数字一样使用），并通过抛出错误、提供默认值等来处理不是数字的值。这样，就可以拥有一个可以利用 JavaScript 提供的全部灵活性的函数，该函数可以根据上下文隐式地转换值。

```js
isNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// 字符串
isNaN("37"); // false：可以被转换成数字 37，不是 NaN
isNaN("37.37"); // false：可以被转换成数字 37.37，不是 NaN
isNaN("37,5"); // true
isNaN("123ABC"); // true：Number("123ABC") 的结果是 NaN
isNaN(""); // false：空字符串被转换成 0，不是 NaN
isNaN(" "); // false：由空格组成的字符串被转换成 0，不是 NaN

// 日期
isNaN(new Date()); // false；Date 对象可以转换为数字（时间戳）
isNaN(new Date().toString()); // true；Date 对象的字符串表示形式不能解析为数字

```

---

## 题目13
下面判断语句正确的有：

![20250511093021](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511093021.png)

> 正确答案：

> JS 转换数字 parseFloat

parseFloat() 函数解析一个参数（必要时先转换为字符串）并返回一个浮点数。

```js
parseFloat(string)
```

给定值被解析成浮点数。如果给定值不能被转换成数值，则会返回 NaN。

parseFloat 是个全局函数，不属于任何对象。

如果 parseFloat 在解析过程中遇到了正号（+）、负号（- U+002D HYPHEN-MINUS）、数字（0-9）、小数点（.）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。
第二个小数点的出现也会使解析停止（在这之前的字符都会被解析）。
参数首位和末位的空白符会被忽略。
如果参数字符串的第一个字符不能被解析成为数字，则 parseFloat 返回 NaN。
parseFloat 也可以解析并返回 Infinity。
parseFloat 解析 BigInt 为 Numbers, 丢失精度。因为末位 n 字符被丢弃。
考虑使用 Number(value) 进行更严谨的解析，只要参数带有无效字符就会被转换为 NaN 。

parseFloat 也可以转换一个已经定义了 toString 或者 valueOf 方法的对象，它返回的值和在调用该方法的结果上调用 parseFloat 值相同。

下面的例子都返回 3.14

```js
parseFloat(3.14);
parseFloat("3.14");
parseFloat("  3.14  ");
parseFloat("314e-2");
parseFloat("0.0314E+2");
parseFloat("3.14some non-digit characters");
parseFloat({
  toString: function () {
    return "3.14";
  },
});
```
下面的例子将返回NaN

```js
parseFloat("FF2");
```

以下例子均返回 900719925474099300，当整数太大以至于不能被转换时将失去精度。

```js
parseFloat(900719925474099267n);
parseFloat("900719925474099267n");

```
---

## 题目14

假设线上代码的分支是master，本地修复bug的分支是fix，上线时下列哪些git操作是正确的。

![20250511093133](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511093133.png)

> 正确答案：AD

> git

## 题目15

在linux系统中，修改文件权限使用的命令是

![20250511093450](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511093450.png)

> 正确答案：BC

> Linux基础

`su`: switch user,切换用户
`chown`: change owner,设置文件所有者和文件关联组
`chmod`: change mode: 控制用户对文件的权限

---

## 题目16

下面关于JavaScript的说法正确的有：

![20250511093601](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511093601.png)

> 正确答案：CD

> JS 数据存储方式

---

## 题目17

已知字符串：‘电话号码是：123-4567-8901'，如下正则表达式可以匹配到字符串中的电话号码的有

![20250511093836](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511093836.png)

> 正确答案 BCD

A. []表示字符集合。匹配方括号中的任何字符。所以A只能匹配形如'13-14-14'的字符。
B. `{n}`表示前一个字符出现了n次。所以可以匹配傻姑娘。
CD. 当连字符在字符集的末尾时，转义与否具有相同的意思。都可以匹配。

> 正则表达式

---

## 题目18

如下方式创建的数据长度为5的有

![20250511094000](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511094000.png)

> 正确答案：ABD
> JS 数组API

A. 在使用字面量方法创建数组时，可以使用逗号当占位符，一个逗号表示一个元素。
B. Array的构造函数参数表示数组长度
C. C是语法错误
D. 表示创建了一个数组，其中有5个元素，都是空字符串。

![20250511094053](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511094053.png)

## 题目19

已知const arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']，下面可以获取数据最后一项的表达式有

![20250511094205](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511094205.png)

> 正确答案：AB

> JS 数组API

---

## 题目20

JavaScript的基本数据类型有

![20250511094329](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511094329.png)

> 正确答案：BDE

> JS 数据类型

## 题目21 


【颜色分类】
问题描述: 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排 列。 
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 

![20250511094624](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511094624.png)

本题解出来并不难，任意方法排序即可。但是想在O(n)的复杂度解出来便需要一下技巧。

因为只有三种元素，所以可以直接通过两次遍历把0和1利用交换来排序到合适的位置即可。

```js
const sort = (arr) => {
  // 指针
  let p = 0;

  // 遍历把0归位
  for (let i = 0; i < arr.length; i++) {
    // 如果当前元素是0，则交换p和i对应的值
    if (arr[i] === 0) {
      [arr[p], arr[i]] = [arr[i], arr[p]];

      // 指针右移一位
      p++;
    }
  }

  // 遍历把1归位
  for (let i = 0; i < arr.length; i++) {
    // 如果当前元素是1，则交换p和i对应的值
    if (arr[i] === 1) {
      [arr[p], arr[i]] = [arr[i], arr[p]];

      // 指针右移一位
      p++;
    }
  }
  return arr;
}

// 测试
const arr = [0, 1, 1, 0, 2, 2, 1, 0, 0, 1, 2, 2, 2,];
console.log(sort(arr));
```

## 题目22

罗马数字转整数。

问题描述: 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M, 分别对应数字：1，5， 10， 50，100，500，1000。例如， 罗马数字 2 写做 II ，即 为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于 大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： 
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 

![20250511175747](https://raw.githubusercontent.com/majialu-love-zouyutong/pictures/main/20250511175747.png)

本题考查哈希表

```js
const romanToInt = (s) => {
  // 哈希表存储罗马数字和阿拉伯数字的映射关系
  const map = new Map(
    [
      ['I', 1],
      ['V', 5],
      ['X', 10],
      ['L', 50],
      ['C', 100],
      ['D', 500],
      ['M', 1000],
    ]
  );

  let sum = 0;

  // 只需要遍历一次，如果当前数字小于后一个数字，则减去当前数字，否则加上当前数字
  for (let i = 0; i < s.length; i++) {
    if (i < s.length - 1 && map.get(s[i]) < map.get(s[i + 1])) {
      sum -= map.get(s[i]);
    } else {
      sum += map.get(s[i]);
    }
  }
  return sum;
}

```