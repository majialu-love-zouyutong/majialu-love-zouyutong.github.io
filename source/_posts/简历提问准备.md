---
title: 简历提问准备
date: 2025-07-13 12:48:08
tags: 简历 面试
---

# 基础问题

## 1. 详细介绍一下JS的原型和原型链？什么是原型？什么是原型链？为什么需要有原型链？怎么使用原型链？要注意什么问题？

### JavaScript 原型及相关机制详解

---

#### 1. 原型与原型链基础

##### 1.1 显式原型（prototype）

- 每个函数（构造函数）都有一个 `prototype` 属性，指向一个对象，称为“显式原型”或“原型对象”。
- 箭头函数没有 `prototype` 属性，且不能作为构造函数。

##### 1.2 隐式原型（[[Prototype]] / __proto__）

- 每个对象都有一个隐式原型，通常通过 `__proto__` 访问（标准是内部属性 `[[Prototype]]`）。
- 通过构造函数 `new` 创建的实例，其隐式原型指向构造函数的 `prototype`。

##### 1.3 原型链

- 当访问对象属性时，JS 引擎先查找对象自身属性，找不到时沿隐式原型链向上查找，直到找到 `Object.prototype`，其隐式原型为 `null`。
- 这条链条即为“原型链”，它决定了继承和属性查找机制。

---

#### 2. 原型存在的意义

- JS 没有传统语言的类型元数据，通过原型实现继承。
- 原型链实现共享方法，减少内存开销。
- 动态修改原型链提供了灵活的继承机制。

---

#### 3. 使用原型链的方法

- 通过构造函数的 `prototype` 定义共享方法。
- 使用 `Object.create(p)` 创建一个以 `p` 为隐式原型的新对象。
- 使用 `Object.setPrototypeOf(a, b)` 动态设置对象 `a` 的隐式原型为 `b`（不建议频繁使用，性能开销较大）。

---

#### 4. 构造函数与原型关系

- 构造函数有 `prototype` 属性，指向显式原型对象。
- 由构造函数 `new` 出来的对象，其隐式原型指向该构造函数的 `prototype`。

---

#### 5. `new` 操作符内部执行流程

1. 创建一个空对象。
2. 设置该对象的隐式原型指向构造函数的 `prototype`。
3. 将构造函数内部的 `this` 指向该对象，执行构造函数代码。
4. 返回构造函数返回的对象（若无则返回新创建对象）。

---

#### 6. `instanceof` 判断原理

- 判断对象 `A` 的原型链上是否存在构造函数 `B` 的 `prototype`。
- 存在则返回 `true`，否则 `false`。

---

#### 7. `constructor` 属性

- 显式原型对象上默认有一个 `constructor` 属性，指向该构造函数。
- 作用：
  - 关联实例和构造函数。
  - 用于手动恢复继承时丢失的构造函数指针。
  - 支持某些场景下动态实例创建。
- 使用 `Object.create` 继承时，原型会丢失 `constructor`，需手动修复。
- 使用 `Object.setPrototypeOf` 修改原型链时，`constructor` 不会丢失。

---

#### 8. 原型链继承的经典写法与注意

- 不建议用 `Child.prototype = new Parent()` 继承，因会调用构造函数带来副作用并共享引用属性。
- 推荐用 `Child.prototype = Object.create(Parent.prototype)` 干净继承原型。
- 修改已有原型的隐式原型 `Object.setPrototypeOf(Child.prototype, Parent.prototype)` 可以保持 `constructor`，但性能可能受影响。

---

#### 9. ES6 `class` 与箭头函数

- 箭头函数不能作为构造函数使用，没有 `[[Construct]]`。
- `class` 是构造函数的语法糖，必须用 `new` 调用，且不能直接调用。
- `class` 中的方法定义在原型上，属性定义在实例上。
- `class` 代码默认启用严格模式。
- 通过 `extends` 实现继承，本质是设置 `Child.prototype` 指向 `Parent.prototype`，以及 `Child.__proto__` 指向 `Parent`，实现实例继承和静态继承。
- 静态方法定义在构造函数本身，需通过类名调用。

---

#### 10. `super` 关键字

- `super()` 在子类构造函数中调用父类构造函数，且绑定子类的 `this`。
- 必须先调用 `super()`，否则访问 `this` 会报错（实例未初始化）。
- `super.method()` 可在子类方法中调用父类方法。
- 静态方法中 `super` 调用父类静态方法。

---

#### 11. `new.target`

- `new.target` 用于判断函数或类是否通过 `new` 调用。
- 通过 `new` 调用时，`new.target` 指向被调用的构造函数或类。
- 普通调用时，`new.target` 为 `undefined`。
- 典型用途：
  - 确保构造函数必须用 `new` 调用。
  - 实现抽象类，防止基类被实例化。

---

### 总结

JavaScript 的原型机制及其衍生的 `new`、`instanceof`、`constructor` 等核心特性构成了对象继承的基础；ES6 `class` 和 `super`、`new.target` 等语法糖和新特性在语义上清晰了函数的职责，减少了误用，提高了代码可维护性和开发效率。

