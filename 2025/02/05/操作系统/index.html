<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | 马嘉路</title><meta name="author" content="马嘉路"><meta name="copyright" content="马嘉路"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统的概念,功能操作系统的概念(定义)操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织调度计算机的工作和资源的分配;以提供给用户和其他软件方便的接口环境;它是计算机中最基本的系统软件 提供的功能 处理机(CPU)管理 存储器(内存)管理 文件管理 设备管理  目标向上层提供方便易用的方式  GUI  联机命令接口(交互式命令接口)">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2025/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="马嘉路">
<meta property="og:description" content="操作系统的概念,功能操作系统的概念(定义)操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织调度计算机的工作和资源的分配;以提供给用户和其他软件方便的接口环境;它是计算机中最基本的系统软件 提供的功能 处理机(CPU)管理 存储器(内存)管理 文件管理 设备管理  目标向上层提供方便易用的方式  GUI  联机命令接口(交互式命令接口)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover.jpg">
<meta property="article:published_time" content="2025-02-05T05:08:44.000Z">
<meta property="article:modified_time" content="2025-10-18T11:32:24.400Z">
<meta property="article:author" content="马嘉路">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统",
  "url": "http://example.com/2025/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
  "image": "http://example.com/img/cover.jpg",
  "datePublished": "2025-02-05T05:08:44.000Z",
  "dateModified": "2025-10-18T11:32:24.400Z",
  "author": [
    {
      "@type": "Person",
      "name": "马嘉路",
      "url": "https://github.com/majialu-love-zouyutong.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 马嘉路","link":"链接: ","source":"来源: 马嘉路","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.png" alt="Logo"><span class="site-name">马嘉路</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-folder"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-05T05:08:44.000Z" title="发表于 2025-02-05 13:08:44">2025-02-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-18T11:32:24.400Z" title="更新于 2025-10-18 19:32:24">2025-10-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="操作系统的概念-功能"><a href="#操作系统的概念-功能" class="headerlink" title="操作系统的概念,功能"></a>操作系统的概念,功能</h1><h2 id="操作系统的概念-定义"><a href="#操作系统的概念-定义" class="headerlink" title="操作系统的概念(定义)"></a>操作系统的概念(定义)</h2><p>操作系统(Operating System, OS)是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源,并合理地组织调度计算机的工作和资源的分配;以<strong>提供给用户和其他软件方便的接口环境</strong>;它是计算机中最基本的<strong>系统软件</strong></p>
<h2 id="提供的功能"><a href="#提供的功能" class="headerlink" title="提供的功能"></a>提供的功能</h2><ul>
<li>处理机(CPU)管理</li>
<li>存储器(内存)管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>向上层提供方便易用的方式</p>
<ul>
<li><p>GUI</p>
</li>
<li><p>联机命令接口(交互式命令接口)</p>
</li>
<li><p>脱机命令接口(批处理命令接口),文件后缀为<code>.bat</code></p>
</li>
<li><p>程序接口: 可以在程序中进行<strong>系统调用</strong>来使用程序接口.普通用户不能直接使用程序接口,只能通过程序代码<strong>间接调用</strong></p>
</li>
</ul>
<blockquote>
<p>系统调用&#x3D;广义指令</p>
</blockquote>
<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发</strong>: 指两个或多个事件在同一时间间隔内发生.这些事件在<strong>宏观上是同时发生的</strong>,但<strong>微观上是交替发生的</strong></p>
<p><strong>操作系统的并发性</strong>:指计算机系统中”同时”运行着多个程序,这些程序宏观上看是同时运行着的,而微观上是交替运行的.</p>
<p>操作系统就是伴随着”多道程序技术”而出现的.因此,<strong>操作系统和程序并发是一起诞生的</strong></p>
<blockquote>
<p><strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>,各个程序只能<strong>并发</strong>执行</p>
<p><strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>,多个程序可以<strong>并行</strong>的执行</p>
</blockquote>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p><strong>共享</strong>:即资源共享,是指系统中的资源可供内存中多个并发执行的进程共同使用.</p>
<p>两种共享方式:</p>
<ul>
<li>互斥共享: 一个时间段内只允许一个进程访问该资源</li>
<li>允许一个时间段内由多个进程”同时”对他们进行访问</li>
</ul>
<blockquote>
<p>并发和共享的关系</p>
<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序.</p>
<p><strong>共享性</strong>指系统中的资源可供内存中多个并发执行的进程共同使用</p>
<p>如果失去并发性,共享性就没有存在的意义</p>
<p>如果失去共享性,并发性就不可能实现</p>
</blockquote>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p><strong>虚拟</strong>是指把一个物理上的实体变为若干个逻辑上的对应物.物理实体(前者)是实际存在的,而逻辑上对应物(后者)是用户感受到的.</p>
<p>虚拟技术</p>
<ul>
<li>空分复用技术(如虚拟存储器技术)</li>
<li>时分复用技术(如虚拟处理器)</li>
</ul>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p><strong>异步</strong>是指,在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,而是走走停停,以<strong>不可预知</strong>的速度向前推进,这就是进程的异步性.</p>
<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><p>用户独占全机,人机交互效率低.</p>
<h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><p>引入<strong>脱机输入&#x2F;输出技术</strong>,并由<strong>监督程序</strong>负责控制作业的输入,输出</p>
<p>优点: 缓解了一定程度人机速度不同</p>
<p>缺点: 效率还是很低,没有人机交互功能</p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>以<strong>时间片</strong>为单位,<strong>轮流为各个用户&#x2F;作业服务</strong>,各个用户可通过终端与计算机进行交互.</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>优点: 能够优先响应一些紧急任务,某些紧急任务不需要时间片排队.</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><h1 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h1><h2 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h2><ul>
<li><p>特权指令</p>
</li>
<li><p>非特权指令</p>
</li>
</ul>
<h2 id="两种状态"><a href="#两种状态" class="headerlink" title="两种状态"></a>两种状态</h2><ul>
<li>内核态(管态)</li>
<li>用户态(目态)</li>
</ul>
<p>内核态-&gt;用户态: 执行一条<strong>特权指令</strong>,修改PSW状态为为用户态</p>
<p>用户态-&gt;内核台: 由中断引起,硬件自动完成.</p>
<p><strong>程序状态寄存器(PSW)</strong></p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><p>CPU上会运行两种程序,一种是<strong>操作系统的内核程序</strong>,一种是<strong>应用程序</strong></p>
<p>在合适的情况下,操作系统内核会把CPU的使用权主动让给应用程序</p>
<p>中断是让<strong>操作系统夺回CPU使用权</strong>的唯一途径</p>
<blockquote>
<p>如果没有中断机制,那么一旦应用上CPU运行,CPU就会一直运行这个应用程序.</p>
<p>就失去了”并发性”</p>
</blockquote>
<h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><h3 id="内中断-也成为异常"><a href="#内中断-也成为异常" class="headerlink" title="内中断(也成为异常)"></a>内中断(也成为异常)</h3><p>与当前执行的指令<strong>有关</strong>,中断信号来源于CPU的<strong>内部</strong></p>
<ul>
<li>陷阱,陷入(tarp): 由<strong>陷入指令</strong>引发,是应用程序故意引发的.</li>
<li>故障(fault): 由错误条件引起的,可能被内核程序修复.内核程序修复故障后会把CPU的使用权还给应用程序.让它继续执行下去,如:缺页故障</li>
<li>终止(abort): 由致命错误引起的,内核程序无法修复该错误,因此一般不再将CPU使用权还给引发终止的应用程序,而是直接终止该应用程序.如:整数除以0,非法使用特权指令.</li>
</ul>
<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>与当前执行的指令<strong>无关</strong>,中断信号来源于CPU的<strong>外部</strong></p>
<p>例如时钟中断和IO中断</p>
<h2 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h2><p><strong>不同的中断信号,需要用不同的中断处理程序来处理</strong>.当CPU检测到中断信号后,会根据中断信号的类型去查询<strong>中断向量表</strong>,以此来找到响应的中断处理程序在内存中存放的位置.</p>
<blockquote>
<p>中断处理程序是<strong>内核程序</strong></p>
</blockquote>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口,需要向上提供一些简单易用的服务.主要包括<strong>命令接口</strong>和<strong>程序接口</strong>.其中程序接口由一组<strong>系统调用</strong>组成.</p>
<p><img src="/image-20250205143231825.png" alt="image-20250205143231825"></p>
<p><strong>系统调用</strong>是操作系统提供给应用程序(程序员&#x2F;编程人员)使用的接口,可以理解为一种可供应用程序调用的特殊函数,<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
<h2 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h2><p><img src="/image-20250205143809721.png" alt="image-20250205143809721"></p>
<h2 id="什么功能要用到系统调用"><a href="#什么功能要用到系统调用" class="headerlink" title="什么功能要用到系统调用"></a>什么功能要用到系统调用</h2><ul>
<li>设备管理: 完成设备的请求&#x2F;释放&#x2F;启动等功能</li>
<li>文件管理: 完成文件的读&#x2F;写&#x2F;创建&#x2F;删除等功能</li>
<li>进程控制: 完成进程的 创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒 等功能</li>
<li>进程通信: 完成进程之间的 消息传递&#x2F;信号传递 等功能</li>
<li>内存管理: 完成内存的 分配&#x2F;回收 等功能</li>
</ul>
<p>应用程序通过<strong>系统调用</strong>请求操作系统的服务.而系统重的各种共享资源都由操作系统的内核统一掌管,因此<strong>凡是与共享资源有关的操作(如存储分配,I&#x2F;O操作,文件管理等),都必须通过系统调用的方式想操作系统内核提出服务请求</strong>,由操作系统代为完成.这样<strong>可以保证系统的稳定性和安全性</strong>,防止用户进行非法操作.</p>
<h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><p><img src="/image-20250205144907078.png" alt="image-20250205144907078"></p>
<p>传递系统调用参数-&gt;执行陷入指令(用户态)-&gt;执行相应的请求内核程序处理系统调用(核心态)-&gt;返回应用程序</p>
<blockquote>
<p>注意:</p>
<ol>
<li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的,执行陷入指令之后立即引发一个<strong>内中断</strong>,使CPU进入<strong>内核态</strong></li>
<li>发出系统调用请求是在<strong>用户态</strong>,而<strong>对系统调用的相应处理</strong>在<strong>核心态</strong>下进行</li>
</ol>
</blockquote>
<h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><p><img src="/image-20250205145240266.png" alt="image-20250205145240266"></p>
<p><strong>内核</strong>是操作系统最基本,最核心的部分.</p>
<p><img src="/image-20250205145319607.png" alt="image-20250205145319607"></p>
<p><img src="/image-20250205145409645.png" alt="image-20250205145409645"></p>
<p><img src="/image-20250205145506052.png" alt="image-20250205145506052"></p>
<h1 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h1><h2 id="什么是操作系统引导"><a href="#什么是操作系统引导" class="headerlink" title="什么是操作系统引导"></a>什么是操作系统引导</h2><p>操作系统引导(boot)</p>
<ol>
<li>CPU从一个特定主存地址开始,取指令,执行ROM中的引导程序(先进行硬件自检,再开机)</li>
<li>将磁盘的第一块–主引导记录(MBR)读入内存,执行磁盘引导程序,扫描分区表</li>
<li>从活动分区(又称为主分区, 即安装了操作系统的分区)读入分区引导记录,执行其中的程序.</li>
<li>从根目录下找到完整的操作系统初始化程序(即<strong>启动管理器</strong>)并执行,完成开机的一系列动作.</li>
</ol>
<p><img src="/image-20250205145846544.png" alt="image-20250205145846544"></p>
<p><img src="/image-20250205150215175.png" alt="image-20250205150215175"></p>
<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机: 使用虚拟机技术,将一台物理机器虚拟化为多台虚拟机器(Virtual Machine, VM),每个虚拟机器都可以独立运行一个操作系统.</p>
<p>同义术语: 虚拟机管理程序&#x2F;虚拟机监控程序(Virtual Machine Monitor&#x2F;Hypervisor)</p>
<p><img src="/image-20250205150417832.png" alt="image-20250205150417832"></p>
<h1 id="进程的概念-组成-特征"><a href="#进程的概念-组成-特征" class="headerlink" title="进程的概念,组成,特征"></a>进程的概念,组成,特征</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序: 是<strong>静态的</strong>,就是个存放在磁盘里的可执行文件,就是一系列的指令集合.</p>
<p>进程(Process): 是<strong>动态的</strong>,是程序的一次执行过程.</p>
<blockquote>
<p>同一个程序多次执行会对应多个进程.</p>
</blockquote>
<p>当进程被创建时,操作系统会为该进程分配一个<strong>唯一的,不重复</strong>的”身份证号”, –<strong>PID</strong>(Process ID, 进程ID)</p>
<h2 id="PCB-给操作系统用"><a href="#PCB-给操作系统用" class="headerlink" title="PCB:给操作系统用"></a>PCB:给操作系统用</h2><p>进程控制块(Process Control Block),是进程存在的唯一标志,当进程被创建时,操作系统为其创建PCB,当进程结束时,会回收其PCB.</p>
<ul>
<li>进程描述信息<ul>
<li>进程标识符PID</li>
<li>用户标识符UID</li>
</ul>
</li>
<li>进程控制和管理信息<ul>
<li>CPU,磁盘,网络流量使用情况统计</li>
<li>进程当前状态: 就绪态&#x2F;阻塞态&#x2F;运行态</li>
</ul>
</li>
<li>资源分配清单<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I&#x2F;O设备</li>
</ul>
</li>
<li>处理相关信息<ul>
<li>PSW,PC等等各种寄存器的值(用于实现进程切换)</li>
</ul>
</li>
</ul>
<h2 id="程序段-给进程自己用"><a href="#程序段-给进程自己用" class="headerlink" title="程序段:给进程自己用"></a>程序段:给进程自己用</h2><p>程序的代码(指令序列)</p>
<h2 id="数据段-给进程自己用"><a href="#数据段-给进程自己用" class="headerlink" title="数据段: 给进程自己用"></a>数据段: 给进程自己用</h2><p>运行过程中产生的各种数据(如:程序中定义的变量)</p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>一个进程实体(进程映像)由<strong>PCB,程序段,数据段</strong>组成.</p>
<p>进程是动态的,进程实体(进程映像)是<strong>静态</strong>的</p>
<p>进程实体反映了进程在<strong>某一时刻的状态</strong></p>
<p><img src="/image-20250205153038413.png" alt="image-20250205153038413"></p>
<p><strong>进程</strong>是进程实体的<strong>运行过程</strong>,是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位.</p>
<blockquote>
<p>注意: PCB是进程存在的唯一标志.</p>
</blockquote>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>程序是静态的,进程是动态的,相比于程序,进程拥有以下特征</p>
<ul>
<li>动态性: 进程是程序的一次执行过程,是动态地产生,变化和消亡的</li>
<li>并发性: 内存中有多个进程实体,各进程可并发执行</li>
<li>独立性: 进程是能独立运行,独立获得资源,独立接受调度的基本单位</li>
<li>异步性: 各进程按各自独立的,不可预知的速度向前推进,操作系统要提供<strong>进程同步机制</strong>来解决异步问题</li>
<li>结构性: 每个进程都会配置一个PCB.结构上看,进程由程序段,数据段,PCB组成.</li>
</ul>
<h1 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>三种基本状态</p>
<ul>
<li>运行状态:该进程正在CPU上运行</li>
<li>就绪状态:当进程创建完成后,进入就绪态,此时进程已经具备运行条件,但是由于没有空闲的CPU,就暂时不能运行.</li>
<li>阻塞状态:在进程运行的过程中,可能会<strong>请求等待某个事件的发生</strong>,在这个事件发生之前,进程无法继续往下执行,此时操作系统会让这个进程下CPU,并让它进入<strong>阻塞态</strong>,当CPU空闲时,又会选择另一个就绪态的进程在CPU上运行</li>
</ul>
<p>其他状态:</p>
<ul>
<li>创建状态:进程正在被创建时的状态,在这个阶段操作系统会为进程分配资源,初始化PCB.</li>
<li>终止状态:一个进程可以执行<code>exit</code>系统调用,请求操作系统终止该进程.操作系统会让该进程下CPU,并回收内存空间等资源,最后还要回收该进程的PCB.当终止进程的工作完成之后,该进程就彻底消失了.</li>
</ul>
<h2 id="状态间的转换"><a href="#状态间的转换" class="headerlink" title="状态间的转换"></a>状态间的转换</h2><p><img src="/image-20250205154756608.png" alt="image-20250205154756608"></p>
<p>进程PCB中,会有一个变量<code>state</code>来表示进程的当前状态.如:1表示创建态,2表示就绪态,3表示运行态等.</p>
<p>为了对同一个状态下的各个进程进行统一的管理,操作系统会将各个进程的PCB组织起来</p>
<h2 id="进程的组织方式-各个进程PCB的组织方式"><a href="#进程的组织方式-各个进程PCB的组织方式" class="headerlink" title="进程的组织方式(各个进程PCB的组织方式)"></a>进程的组织方式(各个进程PCB的组织方式)</h2><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><p><img src="/image-20250205155022213.png" alt="image-20250205155022213"></p>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><p><img src="/image-20250205155041696.png" alt="image-20250205155041696"></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>进程控制主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能.</p>
<p>简化理解: 反正进程控制就是要实现<strong>进程状态的转换</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/image-20250205155346657.png" alt="image-20250205155346657"></p>
<p><img src="/image-20250205161345394.png" alt="image-20250205161345394"></p>
<h2 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h2><p><strong>原语</strong>的执行具有<strong>原子性</strong>,即执行过程只能一气呵成,期间<strong>不允许被中断</strong></p>
<p>可以用<strong>关中断</strong>指令和<strong>开中断</strong>指令这两个<strong>特权指令</strong>实现原子性.</p>
<p><img src="/image-20250205161524948.png" alt="image-20250205161524948"></p>
<ul>
<li>进程的创建<ul>
<li>创建原语<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ul>
</li>
<li>引起进程创建的事件<ul>
<li>用户登录: 分时系统中,用户登录成功,系统会为其建立一个新的进程</li>
<li>作业调度: 多道批处理系统中,有新的作业放入内存,会为其建立一个新的进程</li>
<li>提供服务: 用户向操作系统提出某些请求时,会新建一个进程处理该请求</li>
<li>应用请求: 由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止<ul>
<li>撤销原语<ul>
<li>从PCB集合中找到终止的PCB</li>
<li>若进程正在运行,立即剥夺CPU,将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引发进程终止的事件<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞<ul>
<li>阻塞原语<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场,将PCB状态信息设置为阻塞态,暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒<ul>
<li>唤醒原语<ul>
<li>在事件阻塞队列中找到PCB</li>
<li>将PCB从阻塞队列移除,设置进程为就绪态</li>
<li>将PCB插入就绪队列,等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件: 等待的事件完成</li>
</ul>
</li>
<li>进程的切换<ul>
<li>切换原语<ul>
<li>将运行环境信息存入PCB(保存必要的寄存器信息)</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行,并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件<ul>
<li>当前进程时间片到</li>
<li>有更优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程间的通信(Inter-Process Communication, IPC)是指两个进程之间产生数据交互.</p>
<p>进程是分配系统资源的单位(包括内存地址空间),因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong></p>
<p>为了保证安全,一个进程不能直接访问另一个进程的地址空间</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><h3 id="基于数据结构的共享"><a href="#基于数据结构的共享" class="headerlink" title="基于数据结构的共享"></a>基于数据结构的共享</h3><p>基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组.这种共享方式速度慢,限制多,是一种<strong>低级通信</strong>方式.</p>
<p><img src="/image-20250205165520571.png" alt="image-20250205165520571"></p>
<h3 id="基于存储区的共享"><a href="#基于存储区的共享" class="headerlink" title="基于存储区的共享"></a>基于存储区的共享</h3><p>基于存储区的共享:操作系统在内存中划出一块共享存储区,数据的形式,存放位置都由通信进程控制,而不是操作系统.这种共享方式速度很快,是一种<strong>高级通信</strong>方式.</p>
<p><img src="/image-20250205165308925.png" alt="image-20250205165308925"></p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>进程间的数据交换以<strong>格式化的消息(Message)<strong>为单位.进程通过操作系统提供的”发送消息&#x2F;接收消息”两个</strong>原语</strong>进行数据交换.</p>
<p>消息头包括:发送进程ID,接收进程ID,消息长度等格式化信息.</p>
<h3 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h3><p>消息发送进程要指明接收进程的ID</p>
<p><img src="/image-20250205165856958.png" alt="image-20250205165856958"></p>
<h3 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h3><p>通过”信箱”间接地通信.因此又称为”信箱通信方式”</p>
<p><img src="/image-20250205170116815.png" alt="image-20250205170116815"></p>
<h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>“管道”是一个特殊的共享文件,又名<code>pipe</code>文件.其实就是在内存中开辟一个大小固定的内存缓冲区.</p>
<ol>
<li>管道只能支持<strong>半双工</strong>通信,某个时间段内只能实现单向的传输.如果要实现<strong>双向同时通信</strong>,则<strong>需要设置两个管道</strong>.</li>
<li>各进程要<strong>互斥</strong>地访问管道(由操作系统实现)</li>
<li>当管道写满时,写进程将阻塞,直到读进程将管道中的数据取走,即可唤醒写进程</li>
<li>当管道读空时,读进程将阻塞,直到写进程往管道中写入数据,即可唤醒读进程</li>
<li>管道中的数据一旦被读出,就彻底消失.因此,当多个进程读同一个管道时,可能会错乱.对此,通常有两种解决方案<ul>
<li>一个管道允许多个写进程,一个读进程(2014年408真题高教社官方答案)</li>
<li>允许有多个写进程,多个读进程,但系统会让各个读进程轮流从管道中读数据(Linux方案)</li>
</ul>
</li>
</ol>
<h1 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a>线程的概念与特点</h1><p>传统的进程是程序执行流的最小单位.</p>
<p>有的进程可以需要”同时”做很多事情,而传统的进程只能串行地执行一系列程序.为此,引入了”线程”,来增加并发度.</p>
<p>在引入线程后,线程成了程序执行流的最小单位.</p>
<blockquote>
<p>可以把线程理解为<strong>轻量级进程</strong></p>
</blockquote>
<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>,也就是<strong>程序执行流的最小单位</strong>.</p>
<p>引入线程之后,不仅是进程之间可以并发,进程内的<strong>各线程之间</strong>也可以<strong>并发</strong>,从而进一步<strong>提升了系统的并发度</strong>,使得每一个进程内也可以并发处理各种任务(如QQ视频,文字聊天,传文件);</p>
<p>引入线程之后,进程只作为<strong>除CPU之外的系统资源的分配单元</strong>(如打印机,内存地址空间等都是分配给进程的)</p>
<h2 id="带来的变化"><a href="#带来的变化" class="headerlink" title="带来的变化"></a>带来的变化</h2><h3 id="资源分配-调度"><a href="#资源分配-调度" class="headerlink" title="资源分配,调度"></a>资源分配,调度</h3><ul>
<li>传统进程机制中,进程是资源分配,调度的基本单位.</li>
<li>引入线程之后,进程是自愿分配的基本单位,线程是调度的基本单位.</li>
</ul>
<h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><ul>
<li>传统进程机制中,只能进程之间并发</li>
<li>引入线程后,各线程间也能并发,提升了并发度</li>
</ul>
<h3 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h3><ul>
<li>传统的进程间并发,需要切换进程的运行环境,系统的开销很大</li>
<li>线程间的并发,如果是同一进程内的线程切换,则不需要切换进程环境,系统开销小.</li>
<li>引入线程后,并发所带来的系统开销减小</li>
</ul>
<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中,各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID,线程控制块(TCB)</li>
<li>线程也有就绪,阻塞,运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间,同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换,不会引起进程切换</li>
<li>不同进程中的线程切换,会引起进程切换</li>
<li>切换同进程内的线程,系统开销很小.</li>
<li>切换进程,系统开销较大</li>
</ul>
<h1 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h1><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程-User-Level-Thread-ULT"><a href="#用户级线程-User-Level-Thread-ULT" class="headerlink" title="用户级线程(User-Level Thread, ULT)"></a>用户级线程(User-Level Thread, ULT)</h3><p>早期的操作系统(如:早期Unix)只支持进程,不支持线程.当时的”线程”是由线程库实现的.</p>
<p><img src="/image-20250208145219450.png" alt="image-20250208145219450"></p>
<p>很多编程语言提供了强大的线程库,可以实现线程的创建,销毁,调度等功能.</p>
<ul>
<li>线程的管理工作由应用程序通过线程库实现,所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>(包括线程切换)</li>
<li>线程切换在<strong>用户态下</strong>即可完成,无需操作系统的干预.</li>
<li>在用户看来,是有多个线程,但是在操作系统内核看来,并意识不到线程的存在.</li>
<li>优缺点:<ul>
<li>优点: 线程切换在用户空间即可完成,不需要切换到核心态,线程管理的<strong>系统开销小,效率高</strong></li>
<li>缺点: 如果其中一个线程被阻塞,整个进程都会被阻塞,并发度不高.而且多个线程<strong>不可在多核处理机上并行运行</strong>.</li>
</ul>
</li>
</ul>
<h3 id="内核级线程-Kernel-Level-Thread-KLT"><a href="#内核级线程-Kernel-Level-Thread-KLT" class="headerlink" title="内核级线程(Kernel-Level Thread, KLT)"></a>内核级线程(Kernel-Level Thread, KLT)</h3><ul>
<li>线程管理工作由<strong>操作系统内核</strong>完成</li>
<li>线程调度,切换等工作都由内核负责,因此<strong>内核级线程的切换</strong>必须要在<strong>核心态</strong>下才能完成.</li>
<li>操作系统会为每个内核级线程建立相应的TCB(Thread Control Block, 线程控制块),通过TCB对线程进行管理.</li>
<li>优缺点:<ul>
<li>优点: 当一个线程被阻塞后,别的线程还可以继续执行,并发能力强.多线程可在多核处理机上并行执行.</li>
<li>缺点: 一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成,需要切换到核心态,因此线程管理成本高,开销大</li>
</ul>
</li>
</ul>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><ul>
<li>一对一模型: 一个用户级线程映射到一个内核级线程.每个用户进程有与用户级线程同数量的内核级线程.<ul>
<li>优点: 当一个线程被阻塞后,别的线程还可以继续执行,并发能力强.多线程可在多核处理机上并行执行.</li>
<li>缺点: 一个用户进程会占用多个内核级线程,线程切换由操作系统完成,需要切换到核心态,线程管理成本高,开销大.</li>
</ul>
</li>
<li>多对一模型: 多个用户线程映射到一个内核级线程.且一个进程只被分配一个内核级线程.<ul>
<li>优点: 用户级线程切换在用户空间即可完成,不需要切换到核心态,线程管理的系统开销小,效率高.</li>
<li>缺点: 当一个用户线程别阻塞后,整个进程都会被阻塞,并发度不高.多个线程不可在多核处理机上并行运行.</li>
</ul>
</li>
<li>多对多模型: n用户级线程映射到m个内核级线程(n&gt;&#x3D;m).<ul>
<li>克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞),又克服了一对一模型中一个用户进程占用太多内核级线程,开销太大的缺点.</li>
</ul>
</li>
</ul>
<blockquote>
<p>用户级线程是”代码逻辑”的载体</p>
<p>内核级线程是”运行机会”的载体</p>
<p><strong>内核级线程才是处理机分配的单位</strong>.例如:多核CPU环境下,两个内核级线程最多被分配两个核.</p>
</blockquote>
<p>一段”代码逻辑”只有获得了”运行机会”才能被CPU执行.</p>
<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码,只有两个内核级线程中正在运行的代码逻辑都阻塞时,整个进程才会阻塞.</p>
<h1 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h1><p><img src="/image-20250208151114673.png" alt="image-20250208151114673"></p>
<p><img src="/image-20250208151925309.png" alt="image-20250208151925309"></p>
<h1 id="处理机调度的概念-层次"><a href="#处理机调度的概念-层次" class="headerlink" title="处理机调度的概念,层次"></a>处理机调度的概念,层次</h1><h2 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h2><p>当有一堆任务要处理,但由于资源有限,所以事情没法同时处理.这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的顺序,这就是”调度”研究的问题.</p>
<h2 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p><strong>高级调度(作业调度)</strong>.按一定的原则,从外存的作业后备队列中挑选一个作业调入内存,并创建进程.<strong>每个作业只调入一次,调出一次</strong>.作业调入时会建立PCB,调出时才撤销PCB.</p>
<h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p><strong>低级调度(进程调度&#x2F;处理机调度)</strong>:按照某种策略从就绪队列中选取一个进程,将处理机分配给它.</p>
<p>进程调度是操作系统中<strong>最基本的一种调度</strong>,在一般的操作系统中都必须配置进程调度.</p>
<p>进程调度的<strong>频率很高</strong>,一般几十毫秒一次.</p>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>内存不够时,可将某些进程的数据调出外存.等内存空闲或者进程需要运行时再重新调入内存.</p>
<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>.被挂起的进程PCB会被组织成<strong>挂起队列</strong>.</p>
<p><strong>中级调度(内存调度)</strong>:按照某种策略决定将哪个处于挂起状态的进程重新调入内存.</p>
<p>一个进程可能会被多次调出,调入内存,因此<strong>中级调度</strong>发生的<strong>频率</strong>要比高级调度<strong>更高</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>要做什么</th>
<th>调度发生在</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度(作业调度)</td>
<td>按照某种规则,从后备队列中选择合适的作业将其调入内存,并为其创建进程</td>
<td>外存-&gt;内存<br />面向作业</td>
<td>最低</td>
<td>无-&gt;创建态-&gt;就绪态</td>
</tr>
<tr>
<td>中级调度(内存调度)</td>
<td>按照某种规则,从挂起队列中选择合适的进程将其数据调回内存.</td>
<td>外存-&gt;内存<br />面向进程</td>
<td>中等</td>
<td>挂起态-&gt;就绪态<br />(阻塞挂起-&gt;阻塞态)</td>
</tr>
<tr>
<td>低级调度(进程调度)</td>
<td>按照某种规则,从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>最高</td>
<td>就绪态-&gt;运行态</td>
</tr>
</tbody></table>
<h2 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h2><p>暂时调到外存等待的进程状态为<strong>挂起状态(挂起态, suspend)</strong></p>
<p>挂起态又可以进一步细分为<strong>就绪挂起,阻塞挂起</strong>两种状态.</p>
<p>五状态模型-&gt;七状态模型</p>
<p><img src="/image-20250208153056087.png" alt="image-20250208153056087"></p>
<h1 id="进程调度的时机-切换与过程-方式"><a href="#进程调度的时机-切换与过程-方式" class="headerlink" title="进程调度的时机,切换与过程,方式"></a>进程调度的时机,切换与过程,方式</h1><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p><strong>进程调度(低级调度)</strong>,就是按照某种算法从就绪队列中选择一个进程为其分配处理机.</p>
<ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如:等待IO)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事要处理(如I&#x2F;O中断)</li>
<li>有更高优先级的进程要进入就绪队列</li>
</ul>
</li>
</ul>
<p>不能进行进程调度与切换的情况</p>
<ul>
<li>在<strong>处理中断的过程中</strong>.中断的处理过程复杂,与硬件密切相关,很难做到在中断处理过程中进行进程切换.</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中</li>
<li>在<strong>原子操作过程中(原语)</strong>.原子操作不可中断,要一气呵成.</li>
</ul>
<blockquote>
<p>临界资源: 一个时间段内只允许一个进程使用的资源.各进程需要<strong>互斥地</strong>访问临界资源.</p>
<p>临界区: 访问临界资源的那段代码</p>
</blockquote>
<p><strong>内核程序临界区</strong>一般是用来访问<strong>某种内核数据结构</strong>的,比如进程的就绪队列(由各就绪进程的PCB组成)</p>
<p><img src="/image-20250208155038514.png" alt="image-20250208155038514"></p>
<h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><h3 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h3><p>又称为<strong>非抢占式</strong>.即,只允许进程主动放弃处理机.在运行过程中即便有更紧迫的任务到达,当前进程仍然会继续使用处理机,直到该进程终止或主动要求进入阻塞态.</p>
<blockquote>
<p>实现简单,系统开销小,但是无法及时处理紧急任务,适合早期的批处理系统</p>
</blockquote>
<h3 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h3><p>又称为<strong>抢占方式</strong>.当一个进程正在处理机上执行时,如果有一个更重要或更紧迫的进程需要使用处理机,则立即暂停正在执行的进程,将处理机分配给更重要紧迫的那个进程.</p>
<blockquote>
<p>可以优先处理更紧急的进程,也可以让各进程按时间片轮流执行的功能(通过时钟中断).适合于分时操作系统,实时操作系统</p>
</blockquote>
<h1 id="调度器和闲逛进程"><a href="#调度器和闲逛进程" class="headerlink" title="调度器和闲逛进程"></a>调度器和闲逛进程</h1><h2 id="调度器-调度程序-scheduler"><a href="#调度器-调度程序-scheduler" class="headerlink" title="调度器&#x2F;调度程序(scheduler)"></a>调度器&#x2F;调度程序(scheduler)</h2><p><img src="/image-20250208155806598.png" alt="image-20250208155806598"></p>
<h2 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h2><p>调度程序永远的备胎,当没有其他就绪进程时,运行闲逛进程(idle)</p>
<p>闲逛进程的特性:</p>
<ul>
<li>优先级最低</li>
<li>可以是0地址指令,占一个完整的指令周期(指令周期末尾例行检查中断)</li>
<li>能耗低</li>
</ul>
<h1 id="调度的目标-调度算法的评价指标"><a href="#调度的目标-调度算法的评价指标" class="headerlink" title="调度的目标(调度算法的评价指标)"></a>调度的目标(调度算法的评价指标)</h1><h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p>$$<br>利用率 &#x3D; \frac{忙碌的时间}{总时间}<br>$$</p>
<h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><p>$$<br>系统吞吐量 &#x3D; \frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p>
<h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2><p>作业被<strong>提交给系统</strong>到<strong>作业完成为止</strong>的这段时间的时间间隔.</p>
<p>包括四个部分</p>
<ul>
<li>作业在外存后备队列上等待作业调度(高级调度)的时间</li>
<li>进程在就绪队列上等待进程调度(低级调度)的时间</li>
<li>进程在CPU上的执行时间</li>
<li>进程等待I&#x2F;O操作完成的时间</li>
</ul>
<p>后三项在整个作业的处理过程中,可能发生多次.<br>$$<br>作业周转时间 &#x3D; 作业完成时间 - 作业提交时间<br>$$</p>
<p>$$<br>平均周转时间 &#x3D; \frac{各作业周转时间之和}{作业数}<br>$$</p>
<p>$$<br>带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行的时间} &#x3D; \frac{作业完成时间-作业提交时间}{作业的实际运行时间}<br>$$</p>
<h2 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h2><p>等待时间,指进程&#x2F;作业<strong>处于等待处理机状态时间之和</strong>.</p>
<p>对于<strong>进程</strong>来说,等待时间是指进程建立后<strong>等待被服务的时间之和</strong>,在等待I&#x2F;O完成期间其实进程也是被服务的,所以不计入等待时间之和.</p>
<p>对于<strong>作业</strong>来说,不仅需要考虑<strong>建立进程后的等待时间</strong>,还要加上<strong>作业在外存后备队列中的等待时间</strong></p>
<h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间.</p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><blockquote>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度</li>
<li>抢占式还是非抢占式</li>
<li>优点和缺点</li>
<li>是否会导致<strong>饥饿</strong>(某进程&#x2F;作业长期得不到服务)</li>
</ol>
</blockquote>
<h2 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>主要从”公平”的角度</p>
<h2 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a>短作业优先(SJF)</h2><h2 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a>高响应比优先(HRRN)</h2><h1 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a>同步与互斥的基本概念</h1><h1 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h1><h1 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h1><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h1 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h1><h1 id="用信号量实现进程互斥-同步-前驱关系"><a href="#用信号量实现进程互斥-同步-前驱关系" class="headerlink" title="用信号量实现进程互斥,同步,前驱关系"></a>用信号量实现进程互斥,同步,前驱关系</h1><h1 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h1><h1 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h1><h1 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h1><h1 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h1><h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><h1 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h1><h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><h1 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h1><h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><h1 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h1><h1 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h1><h1 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h1><h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h1 id="基本分段式存储管理方式"><a href="#基本分段式存储管理方式" class="headerlink" title="基本分段式存储管理方式"></a>基本分段式存储管理方式</h1><h1 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h1><h1 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h1><h1 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/majialu-love-zouyutong.github.io">马嘉路</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://example.com/2025/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">马嘉路</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/25/Vue3-js/" title="Vue3.js"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vue3.js</div></div><div class="info-2"><div class="info-item-1">Vue3的重大变化 12345678910111213141516import &#123; ref &#125; from &quot;vue&quot;;export default &#123;    setup() &#123;        // console.log(&#x27;所有生命周期钩子函数之前调用&#x27;)        // console.log(this);   this -&gt; undefined        let count = ref(0);        const increase = () =&gt; &#123;            // 不具有响应式            count.value++;        &#125;;        return &#123;            count,            increase        &#125;   ...</div></div></div></a><a class="pagination-related" href="/2025/02/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/" title="服务器部署"><img class="cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">服务器部署</div></div><div class="info-2"><div class="info-item-1">网站运行机制名词解释域名   www.baidu.com www.taobao.com www.qq.com    域名俗称网址,是由一串用点分隔的名字组成,用于标识互联网上的计算机.   原本用于标识互联网上计算机使用的是IP地址,但是由于IP地址不便于记忆,所以人们设计出比较容易记忆的域名,然后,通过DNS服务器将域名和IP地址关联,这样人们便可以通过记忆域名直接访问到对应的计算机.  DNS服务器  DNS(Domain Name System),可以理解为互联网上的一项服务,他可以将域名转换为其对应的IP地址 可以将其理解为字典,字典中存储的就是域名和IP地址一一对应的键值对. 本地host文件 windows: C:\windows\system32\drivers\etc\hosts mac:...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">马嘉路</div><div class="author-info-description">电子科技大学26届在读,冲刺大厂前端</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">73</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/majialu-love-zouyutong"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/majialu-love-zouyutong" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="/2404816298@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂时无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%8A%9F%E8%83%BD"><span class="toc-text">操作系统的概念,功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%AE%9A%E4%B9%89"><span class="toc-text">操作系统的概念(定义)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">提供的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">操作系统的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-text">并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-text">共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-text">虚拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-text">操作系统的发展与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="toc-text">手工操作阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-text">批处理阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">分时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">网络操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">分布式操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">个人计算机操作系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">操作系统的运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%8C%87%E4%BB%A4"><span class="toc-text">两种指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-text">两种状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">中断的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">中断的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD-%E4%B9%9F%E6%88%90%E4%B8%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">内中断(也成为异常)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-text">外中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">中断机制的基本原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">什么是系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">系统调用和库函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%E8%A6%81%E7%94%A8%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">什么功能要用到系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">系统调用的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">操作系统的体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-text">大内核和微内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-text">操作系统引导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-text">什么是操作系统引导</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E7%89%B9%E5%BE%81"><span class="toc-text">进程的概念,组成,特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PCB-%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8"><span class="toc-text">PCB:给操作系统用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5-%E7%BB%99%E8%BF%9B%E7%A8%8B%E8%87%AA%E5%B7%B1%E7%94%A8"><span class="toc-text">程序段:给进程自己用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5-%E7%BB%99%E8%BF%9B%E7%A8%8B%E8%87%AA%E5%B7%B1%E7%94%A8"><span class="toc-text">数据段: 给进程自己用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">进程的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">进程的特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">状态间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F-%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8BPCB%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-text">进程的组织方式(各个进程PCB的组织方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">链接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-text">索引方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-text">进程控制相关的原语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-text">共享存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-text">基于数据结构的共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AD%98%E5%82%A8%E5%8C%BA%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-text">基于存储区的共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">直接通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">间接通信方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-text">管道通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-text">线程的概念与特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">带来的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D-%E8%B0%83%E5%BA%A6"><span class="toc-text">资源分配,调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="toc-text">并发性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="toc-text">系统开销</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">线程的属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">线程的实现方式和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B-User-Level-Thread-ULT"><span class="toc-text">用户级线程(User-Level Thread, ULT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B-Kernel-Level-Thread-KLT"><span class="toc-text">内核级线程(Kernel-Level Thread, KLT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">多线程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">线程的状态与转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-%E5%B1%82%E6%AC%A1"><span class="toc-text">处理机调度的概念,层次</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">调度的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-text">调度的三个层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">高级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">低级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">中级调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E6%80%81%E4%B8%8E%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">进程的挂起态与七状态模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E6%96%B9%E5%BC%8F"><span class="toc-text">进程调度的时机,切换与过程,方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">进程调度的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">进程调度方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">非剥夺调度方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A5%E5%A4%BA%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">剥夺调度方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%92%8C%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B"><span class="toc-text">调度器和闲逛进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F-scheduler"><span class="toc-text">调度器&#x2F;调度程序(scheduler)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B"><span class="toc-text">闲逛进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E7%9B%AE%E6%A0%87-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-text">调度的目标(调度算法的评价指标)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text">CPU利用率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-text">系统吞吐量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-text">周转时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-text">等待时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-text">响应时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-text">先来先服务(FCFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF"><span class="toc-text">短作业优先(SJF)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN"><span class="toc-text">高响应比优先(HRRN)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">同步与互斥的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">进程互斥的软件实现方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">进程互斥的硬件实现方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-text">信号量机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-%E5%90%8C%E6%AD%A5-%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-text">用信号量实现进程互斥,同步,前驱关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">多生产者-多消费者问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">死锁的处理策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">内存的基础知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">内存管理的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-text">覆盖与交换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">连续分配管理方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">动态分区分配算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">基本分页存储管理的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">基本地址变换机构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">两级页表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">基本分段式存储管理方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">段页式管理方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">请求分页管理方式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/19/%E4%BB%8E0%E5%88%B01%E6%90%AD%E4%B8%80%E4%B8%AAmonorepo%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/" title="从0到1搭一个monorepo项目（二）"><img src="/img/monorepo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从0到1搭一个monorepo项目（二）"/></a><div class="content"><a class="title" href="/2025/10/19/%E4%BB%8E0%E5%88%B01%E6%90%AD%E4%B8%80%E4%B8%AAmonorepo%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/" title="从0到1搭一个monorepo项目（二）">从0到1搭一个monorepo项目（二）</a><time datetime="2025-10-19T16:22:07.282Z" title="更新于 2025-10-20 00:22:07">2025-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/18/%E4%BB%8E0%E5%88%B01%E6%90%AD%E4%B8%80%E4%B8%AAmonorepo%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/" title="从0到1搭一个monorepo项目（一）"><img src="/img/monorepo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从0到1搭一个monorepo项目（一）"/></a><div class="content"><a class="title" href="/2025/10/18/%E4%BB%8E0%E5%88%B01%E6%90%AD%E4%B8%80%E4%B8%AAmonorepo%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/" title="从0到1搭一个monorepo项目（一）">从0到1搭一个monorepo项目（一）</a><time datetime="2025-10-18T13:30:39.092Z" title="更新于 2025-10-18 21:30:39">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/13/%E5%BD%93%E6%88%91%E7%94%A8deepwiki%E6%9D%A5%E5%AD%A6%E4%B9%A0pnpm%E6%BA%90%E7%A0%81/" title="当我用deepwiki来学习pnpm源码"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="当我用deepwiki来学习pnpm源码"/></a><div class="content"><a class="title" href="/2025/06/13/%E5%BD%93%E6%88%91%E7%94%A8deepwiki%E6%9D%A5%E5%AD%A6%E4%B9%A0pnpm%E6%BA%90%E7%A0%81/" title="当我用deepwiki来学习pnpm源码">当我用deepwiki来学习pnpm源码</a><time datetime="2025-10-18T11:39:24.413Z" title="更新于 2025-10-18 19:39:24">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%8725-2-19/" title="面试准备25-2-19"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试准备25-2-19"/></a><div class="content"><a class="title" href="/2025/02/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%8725-2-19/" title="面试准备25-2-19">面试准备25-2-19</a><time datetime="2025-10-18T11:32:25.276Z" title="更新于 2025-10-18 19:32:25">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/" title="面经集合"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面经集合"/></a><div class="content"><a class="title" href="/2025/02/20/%E9%9D%A2%E7%BB%8F%E9%9B%86%E5%90%88/" title="面经集合">面经集合</a><time datetime="2025-10-18T11:32:25.276Z" title="更新于 2025-10-18 19:32:25">2025-10-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 马嘉路</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23licJwdCTNkzOiuBF',
      clientSecret: 'db3ef983a56a96ffaa7a55da43f03bbe66283109',
      repo: 'comments',
      owner: 'majialu-love-zouyutong',
      admin: ['majialu-love-zouyutong'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '6f68dc8060218ed469224154542bbd90'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>